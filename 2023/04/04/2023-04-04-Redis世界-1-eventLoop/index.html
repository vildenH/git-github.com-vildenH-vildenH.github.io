<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="w8blT1tqo50kr-tigHqsJ3RrcDwCYOkvuvBLBEB-a20" />
    <title>
        vilden &#39;s blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/github-dark-dimmed.min.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.1.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-angle-double-left replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            2023-04-04-Redis世界-1-eventLoop
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>看之前redis设计与实现、还有网上解析的文章，大部分都聚焦在redis的数据结构的实现，其实也了解一下redis的事件设计，更好的了解redis的处理过程</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>server.c</p>
<p>main流程</p>
<ol>
<li>各种server的初始化</li>
<li>aeMain(server.el) 循环处理事件</li>
</ol>
<p>其中aeMain就是主线程不断处理事件的函数，入参是个EventLoop，当EventLoop不是终止状态的时候，循环处理Events,aeProcessEvents的第二个参数就是代表本次要处理的时间类型</p>
<pre><code class="c">
int main()&#123;
    //init

    aeMain(server.el);
    aeDeleteEventLoop(server.el);
    return 0;
&#125;

void aeMain(aeEventLoop *eventLoop) &#123;
    eventLoop-&gt;stop = 0;
    while (!eventLoop-&gt;stop) &#123;
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    &#125;
&#125;
</code></pre>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop 的事件分类</p>
<ul>
<li>fileEvent :  网络io (epoll&#x2F;kqueue 事件)</li>
<li>timeEvent : 定时任务&#x2F;延迟任务类的</li>
</ul>
<p>EventLoop定义事件如下</p>
<pre><code class="c">/* State of an event based program */
typedef struct aeEventLoop &#123;
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
&#125; aeEventLoop;
</code></pre>
<p>在redisServer初始化的时候创建,入参是事件队列的大小，默认是 server.maxclients + RESERVED_FDS + 一定冗余空间，<br>然后创建fired,events数组列表，timeEvent结构是链表形式的</p>
<pre><code class="c">aeEventLoop *aeCreateEventLoop(int setsize) &#123;
    aeEventLoop *eventLoop;
    int i;

    monotonicInit();    /* just in case the calling app didn&#39;t initialize */

    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;
    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);
    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fered == NULL) goto err;
    eventLoop-&gt;setsize = setsize;
    eventLoop-&gt;timeEventHead = NULL;
    eventLoop-&gt;timeEventNextId = 0;
    eventLoop-&gt;stop = 0;
    eventLoop-&gt;maxfd = -1;
    eventLoop-&gt;beforesleep = NULL;
    eventLoop-&gt;aftersleep = NULL;
    eventLoop-&gt;flags = 0;
    if (aeApiCreate(eventLoop) == -1) goto err;
    /* Events with mask == AE_NONE are not set. So let&#39;s initialize the
     * vector with it. */
    for (i = 0; i &lt; setsize; i++)
        eventLoop-&gt;events[i].mask = AE_NONE;
    return eventLoop;

err:
    if (eventLoop) &#123;
        zfree(eventLoop-&gt;events);
        zfree(eventLoop-&gt;fired);
        zfree(eventLoop);
    &#125;
    return NULL;b
&#125;
</code></pre>
<h3 id="ApiEvent"><a href="#ApiEvent" class="headerlink" title="ApiEvent"></a>ApiEvent</h3><p>可以看到redis的事件管理兼容不同平台的实现，比如epoll，kqueue</p>
<p>完成不同的aeApiCreate实现</p>
<pre><code class="c">/* Include the best multiplexing layer supported by this system.
 * The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
#include &quot;ae_evport.c&quot;
#else
    #ifdef HAVE_EPOLL
    #include &quot;ae_epoll.c&quot;
    #else
        #ifdef HAVE_KQUEUE
        #include &quot;ae_kqueue.c&quot;
        #else
        #include &quot;ae_select.c&quot;
        #endif
    #endif
#endif

// 以 linux epoll 为例，创建过程将epoll_event 记录在apiState数据结构当中
typedef struct aeApiState &#123;
    int epfd;
    struct epoll_event *events;
&#125; aeApiState;

static int aeApiCreate(aeEventLoop *eventLoop) &#123;
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize);
    if (!state-&gt;events) &#123;
        zfree(state);
        return -1;
    &#125;
    state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
    if (state-&gt;epfd == -1) &#123;
        zfree(state-&gt;events);
        zfree(state);
        return -1;
    &#125;
    anetCloexec(state-&gt;epfd);
    eventLoop-&gt;apidata = state;
    return 0;
&#125;
</code></pre>
<p>poll过程，将epoll返回的事件封装处理，放入fired队列</p>
<pre><code class="c">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;
    aeApiState *state = eventLoop-&gt;apidata;
    int retval, numevents = 0;

    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,
            tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1);
    if (retval &gt; 0) &#123;
        int j;

        numevents = retval;
        for (j = 0; j &lt; numevents; j++) &#123;
            int mask = 0;
            struct epoll_event *e = state-&gt;events+j;

            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;
            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;
            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE;
            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE;
            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;
            eventLoop-&gt;fired[j].mask = mask;
        &#125;
    &#125; else if (retval == -1 &amp;&amp; errno != EINTR) &#123;
        panic(&quot;aeApiPoll: epoll_wait, %s&quot;, strerror(errno));
    &#125;

    return numevents;
&#125;
</code></pre>
<p>mask是一个int类型，用于位计算标识事件类型，位计算1，2，4，8没什么好说的了~</p>
<pre><code class="c">#define AE_NONE 0       /* No events registered. */
#define AE_READABLE 1   /* Fire when descriptor is readable. */
#define AE_WRITABLE 2   /* Fire when descriptor is writable. */
#define AE_BARRIER 4    /* With WRITABLE, never fire the event if the
                           READABLE event already fired in the same event
                           loop iteration. Useful when you want to persist
                           things to disk before sending replies, and want
                           to do that in a group fashion. */
</code></pre>
<h3 id="FileEvent"><a href="#FileEvent" class="headerlink" title="FileEvent"></a>FileEvent</h3><p>主要是处理网络事件，针对各平台的时间进行了一层抽象,fileEvent的数组坐标是直接用的fd，可以看到aeCreateFileEvent的的过程中还是通过aeApiAddEvent完成注册绑定的</p>
<pre><code class="c">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
&#123;
    if (fd &gt;= eventLoop-&gt;setsize) &#123;
        errno = ERANGE;
        return AE_ERR;
    &#125;
    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];

    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
        return AE_ERR;
    fe-&gt;mask |= mask;
    if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;
    if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;
    fe-&gt;clientData = clientData;
    if (fd &gt; eventLoop-&gt;maxfd)
        eventLoop-&gt;maxfd = fd;
    return AE_OK;
&#125;

void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
&#123;
    if (fd &gt;= eventLoop-&gt;setsize) return;
    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];
    if (fe-&gt;mask == AE_NONE) return;

    /* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */
    if (mask &amp; AE_WRITABLE) mask |= AE_BARRIER;

    aeApiDelEvent(eventLoop, fd, mask);
    fe-&gt;mask = fe-&gt;mask &amp; (~mask);
    if (fd == eventLoop-&gt;maxfd &amp;&amp; fe-&gt;mask == AE_NONE) &#123;
        /* Update the max fd */
        int j;

        for (j = eventLoop-&gt;maxfd-1; j &gt;= 0; j--)
            if (eventLoop-&gt;events[j].mask != AE_NONE) break;
        eventLoop-&gt;maxfd = j;
    &#125;
&#125;
</code></pre>
<p>文件事件处理过程,这部分代码就是事件循环处理的核心逻辑了，总得来说通过apipoll获得触发的事件个数，然后遍历fired列表取出对应的fd，并根据事件类型进行对应的事件调用。</p>
<p>此外的点:</p>
<ol>
<li>poll中阻塞的时间怎么计算，如果没有配置AE_DONT_WAIT参数，则根据aeTimeEvent列表中取得一个最近的时间事件，通过计算now-when得到阻塞唤醒的时间</li>
<li>在调用apiPoll 会有before sleep 和 after sleep的钩子，用于完成一些其他功能调用，这些放在后面再看</li>
<li>通常redis会先处理读事件，才处理写事件，这样做的好处是，有时会在处理查询后立即完成响应，因此在可读事件后面执行可写事件更合理一些。但如果该事件设置了AE_BARRIER，在这种情况下，将会反转调用顺序，先执行读事件，再执行写时间。这是有用的情况之一是在 beforeSleep() 中做一些事情，例如在对客户端进行响应之前，要将一个文件同步到磁盘上，则先处理读事件</li>
</ol>
<pre><code class="c">int aeProcessEvents(aeEventLoop *eventLoop, int flags)
&#123;
    int processed = 0, numevents;

    /* Nothing to do? return ASAP */
    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;

    /* Note that we want to call select() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */
    //也就是poll的等待时间，是根据usUntilEarliestTimer计算出来的
    if (eventLoop-&gt;maxfd != -1 ||
        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;
        int j;
        struct timeval tv, *tvp;
        int64_t usUntilTimer = -1;

        if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))
            usUntilTimer = usUntilEarliestTimer(eventLoop);

        if (usUntilTimer &gt;= 0) &#123;
            tv.tv_sec = usUntilTimer / 1000000;
            tv.tv_usec = usUntilTimer % 1000000;
            tvp = &amp;tv;
        &#125; else &#123;
            /* If we have to check for events but need to return
             * ASAP because of AE_DONT_WAIT we need to set the timeout
             * to zero */
            if (flags &amp; AE_DONT_WAIT) &#123;
                tv.tv_sec = tv.tv_usec = 0;
                tvp = &amp;tv;
            &#125; else &#123;
                /* Otherwise we can block */
                tvp = NULL; /* wait forever */
            &#125;
        &#125;

        if (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;
            tv.tv_sec = tv.tv_usec = 0;
            tvp = &amp;tv;
        &#125;

        if (eventLoop-&gt;beforesleep != NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)
            eventLoop-&gt;beforesleep(eventLoop);

        /* Call the multiplexing API, will return only on timeout or when
         * some event fires. */
        numevents = aeApiPoll(eventLoop, tvp);

        /* After sleep callback. */
        if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)
            eventLoop-&gt;aftersleep(eventLoop);

        for (j = 0; j &lt; numevents; j++) &#123;
            int fd = eventLoop-&gt;fired[j].fd;
            aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];
            int mask = eventLoop-&gt;fired[j].mask;
            int fired = 0; /* Number of events fired for current fd. */

            /* Normally we execute the readable event first, and the writable
             * event later. This is useful as sometimes we may be able
             * to serve the reply of a query immediately after processing the
             * query.
             *
             * However if AE_BARRIER is set in the mask, our application is
             * asking us to do the reverse: never fire the writable event
             * after the readable. In such a case, we invert the calls.
             * This is useful when, for instance, we want to do things
             * in the beforeSleep() hook, like fsyncing a file to disk,
             * before replying to a client. */
            int invert = fe-&gt;mask &amp; AE_BARRIER;

            /* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already
             * processed event removed an element that fired and we still
             * didn&#39;t processed, so we check if the event is still valid.
             *
             * Fire the readable event if the call sequence is not
             * inverted. */
            if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;
                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                fired++;
                fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */
            &#125;

            /* Fire the writable event. */
            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;
                if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;
                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                    fired++;
                &#125;
            &#125;

            /* If we have to invert the call, fire the readable event now
             * after the writable one. */
            if (invert) &#123;
                fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */
                if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;
                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc))
                &#123;
                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                    fired++;
                &#125;
            &#125;

            processed++;
        &#125;
    &#125;
    /* Check time events */
    if (flags &amp; AE_TIME_EVENTS)
        processed += processTimeEvents(eventLoop);

    return processed; /* return the number of processed file/time events */
</code></pre>
<h3 id="TimeEvent"><a href="#TimeEvent" class="headerlink" title="TimeEvent"></a>TimeEvent</h3><p>是redis管理时间事件的，比如定时任务、延时任务，就是定时器实现，</p>
<p>创建过程比较简单，用一个递增数字标识id，获取一下任务的执行时间放在when字段中，proc绑定定时任务的函数，然后用头插法插入链表头部</p>
<p>删除过程就是遍历链表，将链表id置为-1，直到线程处理时间事件的时候才进行链表的修改</p>
<pre><code class="c">long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc)
&#123;
    long long id = eventLoop-&gt;timeEventNextId++;
    aeTimeEvent *te;

    te = zmalloc(sizeof(*te));
    if (te == NULL) return AE_ERR;
    te-&gt;id = id;
    te-&gt;when = getMonotonicUs() + milliseconds * 1000;
    te-&gt;timeProc = proc;
    te-&gt;finalizerProc = finalizerProc;
    te-&gt;clientData = clientData;
    te-&gt;prev = NULL;
    te-&gt;next = eventLoop-&gt;timeEventHead;
    te-&gt;refcount = 0;
    if (te-&gt;next)
        te-&gt;next-&gt;prev = te;
    eventLoop-&gt;timeEventHead = te;
    return id;
&#125;

int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
&#123;
    aeTimeEvent *te = eventLoop-&gt;timeEventHead;
    while(te) &#123;
        if (te-&gt;id == id) &#123;
            te-&gt;id = AE_DELETED_EVENT_ID;
            return AE_OK;
        &#125;
        te = te-&gt;next;
    &#125;
    return AE_ERR; /* NO event with the specified ID found */
&#125;
</code></pre>
<p>定时器的执行过程，遍历链表，判断当前节点的id是不是delete id(-1),是的话就执行链表删除操作</p>
<p>至于其他时间器实现就更简单了，也不涉及优先队列时间轮，直接遍历判断当前时间是否超过when了，超过了就执行….<br>执行完了根据返回值看是否还要执行下一次，如果返回值大于零，修改when时间，代表的还有下一次执行，否则的话将id修改为0就完事~</p>
<p>在initServer()中添加了几个事件，其中包含一个时间事件——serverCron。 serverCron以每秒server.hz次数执行 功能比如：</p>
<ol>
<li>驱逐过期的key</li>
<li>客户端超时</li>
<li>信息统计</li>
<li>rehash hashtables</li>
<li>BGSAVE AOF</li>
<li>从库重连</li>
<li>..其他工作</li>
</ol>
<pre><code class="c">/* Process time events */
static int processTimeEvents(aeEventLoop *eventLoop) &#123;
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;

    te = eventLoop-&gt;timeEventHead;
    maxId = eventLoop-&gt;timeEventNextId-1;
    monotime now = getMonotonicUs();
    while(te) &#123;
        long long id;

        /* Remove events scheduled for deletion. */
        if (te-&gt;id == AE_DELETED_EVENT_ID) &#123;
            aeTimeEvent *next = te-&gt;next;
            /* If a reference exists for this timer event,
             * don&#39;t free it. This is currently incremented
             * for recursive timerProc calls */
            if (te-&gt;refcount) &#123;
                te = next;
                continue;
            &#125;
            if (te-&gt;prev)
                te-&gt;prev-&gt;next = te-&gt;next;
            else
                eventLoop-&gt;timeEventHead = te-&gt;next;
            if (te-&gt;next)
                te-&gt;next-&gt;prev = te-&gt;prev;
            if (te-&gt;finalizerProc) &#123;
                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);
                now = getMonotonicUs();
            &#125;
            zfree(te);
            te = next;
            continue;
        &#125;

        /* Make sure we don&#39;t process time events created by time events in
         * this iteration. Note that this check is currently useless: we always
         * add new timers on the head, however if we change the implementation
         * detail, this check may be useful again: we keep it here for future
         * defense. */
        if (te-&gt;id &gt; maxId) &#123;
            te = te-&gt;next;
            continue;
        &#125;

        if (te-&gt;when &lt;= now) &#123;
            int retval;

            id = te-&gt;id;
            te-&gt;refcount++;
            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);
            te-&gt;refcount--;
            processed++;
            now = getMonotonicUs();
            if (retval != AE_NOMORE) &#123;
                te-&gt;when = now + retval * 1000;
            &#125; else &#123;
                te-&gt;id = AE_DELETED_EVENT_ID;
            &#125;
        &#125;
        te = te-&gt;next;
    &#125;
    return processed;
&#125;
</code></pre>

    </div>

</div>
    <div class="footer" id="footer">
    <p>Copyright © 2022 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink">Hao</a>.
        <!-- <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label> -->
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>


<script src="/libs/highlightjs-line-numbers/highlightjs-line-numbers.min.js"></script>


<script src="/js/js.js"></script>


    <script src='https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js'></script>
    <script>
      String.prototype.replaceAll = function(search, replacement) {
        var target = this;
        return target.split(search).join(replacement);
      };
  
      let vizObjects = document.querySelectorAll('.graphviz')
  
      for (let item of vizObjects) {
        let svg = undefined
        try {
          svg = Viz(item.textContent.replaceAll('–', '--'), 'svg')
        } catch(e) {
          svg = `<pre class="error">${e}</pre>`
        }
        item.outerHTML = svg
      }
    </script>
  

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>