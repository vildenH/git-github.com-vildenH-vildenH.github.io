<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vildenh.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Vilden &#39;s blog">
<meta property="og:url" content="https://vildenh.github.io/index.html">
<meta property="og:site_name" content="Vilden &#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="Vilden">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://vildenh.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>

  <title>Vilden 's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vilden 's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/07/24/2023-07-24-Mysql-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/24/2023-07-24-Mysql-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">2023-07-24-Mysql-高可用架构概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-24 15:08:18 / Modified: 15:19:44" itemprop="dateCreated datePublished" datetime="2023-07-24T15:08:18+08:00">2023-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Master-Slave（MS）架构高可用概述"><a href="#Master-Slave（MS）架构高可用概述" class="headerlink" title="Master-Slave（MS）架构高可用概述"></a>Master-Slave（MS）架构高可用概述</h1><h2 id="MS架构高可用基础"><a href="#MS架构高可用基础" class="headerlink" title="MS架构高可用基础"></a>MS架构高可用基础</h2><p>高可用MySQL是依赖复制（Replication）技术实现的，复制解决的基本问题就是，让一台数据库服务器的数据同步到其它服务器上。MySQL数据库的复制有如下三个步骤。</p>
<ol>
<li>在主库上把数据更改记录到二进制日志（Binary Log）中（这些记录被称为二进制日志事件）。</li>
<li>备库将主库上的日志复制到自己的中继日志（Relay Log）中。</li>
<li>备库读取中继日志中的事件（Event），将其回放到备库数据之上。</li>
</ol>
<p>以上只是概述，实际上每一步都很复杂。</p>
<p>复制的主要目的是，保障数据库的可用性，和数据一致性。可用性是指，系统提供的服务一直处于可用状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。一致性是指，数据在多个节点之间是否能够保持一致的特性。在高可用数据库进行Failover时，数据一致性往往会受到比较大的挑战，而数据一致性又极其依赖复制技术本身，其属于数据库的硬核能力。我们的快乐，和不快乐有好大一部分来自数据一致性的问题。数据一致性使用RPO（Recovery Point Objective）来衡量，MySQL的复制也一直在追求着RPO&#x3D;0的境界。</p>
<p>MS架构围绕着复制方式实现高可用，复制的痛点主要围绕着数据一致性。如果第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据，这就是典型的数据不一致的问题。</p>
<p>在高可用数据库进行Failover时，可能数据还没有复制完毕，这样就出现了数据不一致的风险，反应在实际业务上可能是数据丢失了，或错乱了。MySQL在数据复制上进行了旷日持久的改进，由异步复制（Asynchronous Replication）到半同步复制（Semisynchronous Replication），再到增强半同步复制（Enhanced Semisynchronous Replication），几近使RPO趋于0，直至组复制（Group Replication）的出现。</p>
<h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>MySQL默认的复制就是异步复制，主库在执行完用户提交的事务后，将事务事件写入到Binlog文件中，这时主库只会通知Dump线程发送这些新的Binlog，然后主库就会继续处理用户的提交，而不会保证Binlog传送到任何一个备库上。</p>
<p>若主库发生Crash，其上已经提交的事务可能并没有传送到备库上，此时Failover，可能就会导致新主库上的数据不完整，出现了数据不一致性的问题。</p>
<h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>半同步复制与异步复制不同的是，其在主库执行完用户提交的事务后，等待至少一个备库将接收到的Binlog写入Relay Log后，并返回给主库ACK，主库才会继续处理用户的提交。这里主库等待备库返回ACK的时间点，由参数rpl_semi_sync_master_wait_point&#x3D;AFTER_COMMIT设置；等待几个备库返回ACK，由参数rpl_semi_sync_master_wait_for_slave_count&#x3D;1设置。其中还有一个半同步超时的设置，由参数rpl_semi_sync_master_timeout&#x3D;100控制，超时后半同步复制退化为异步复制。</p>
<p>半同步复制提高了数据的安全性，同时也会造成一定程度的延迟，该延迟至少是一个RTT（Round Trip Time）。</p>
<h2 id="增强半同步复制"><a href="#增强半同步复制" class="headerlink" title="增强半同步复制"></a>增强半同步复制</h2><p>增强半同步复制</p>
<p>增强半同步复制（图1-4）与半同步复制的不同之处是，其等待备库返回ACK的时间点不同。在MySQL中一个Commit过程由三个步骤组成：第一，Prepare the transaction in the storage engine (InnoDB)；第二，Write the transaction to the binary logs；第三，Complete the transaction in the storage engine。增强半同步复制等待备库ACK的时间点，由参数rpl_semi_sync_master_wait_point&#x3D;AFTER_SYNC配置，是在Commit的第二，和第三步骤之间。不同于半同步复制等待备库ACK的时间点，是在Commit的第三步骤之后。试想对于增强半同步复制，在主库等待备库返回ACK时发生了Crash，由于该Commit还没最终结束，用户在主库上不会看到变更。当Failover后，用户在新主库上也不会看到变更，不存在数据不一致的问题。而对于半同步复制，由于该Commit已结束，用户在主库上会看到变更。当Failover后，用户在新主库上反而看不到变更，出现了数据不一致的情况。可见增强半同步复制，比半同步复制，在保证数据一致性上又前进了一步。</p>
<p>在增强半同步复制中，可以配置超时参数很大，如rpl_semi_sync_master_timeout&#x3D;999999，这样主库在未收到备库ACK之前，用户的提交是被挂起的，这样更进一步保证了数据一致性，只是在可用性方面大打折扣了。</p>
<h2 id="MGR"><a href="#MGR" class="headerlink" title="MGR"></a>MGR</h2><p>MySQL Group Replication（后简称MGR）的出现让大家眼前一亮，其建设性的以插件（Plugin）的方式添加到MySQL现有体系架构中，基于原生复制技术，使用了Binary Log，Row-based logging，和GTID等特性，使用了Paxos一致性协议的数据复制逻辑，保证了数据的一致性。</p>
<p>显示了MGR与普通MySQL复制模式的区别，在MGR中提交事务时，事务在引擎层完成Prepare，写Binlog之前会被MySQL预设的钩子（Hook）before_commit拦截，进入到MGR层，其将事务执行相关的信息打包，通过Paxos一致性协议（Consensus）进行全局排序后发送给MGR各个节点，当超过半数（N&#x2F;2+1）的节点（包括它自己）回应后，发送消息告诉所有节点，这个数据包同步成功。各节点独自进行认证（Certify）。若认证通过，本地节点写Binlog完成提交。异地节点写Relay Log，由建立的复制通道（Replication Channel）group_replication_applier完成事务并行回放。若认证不通过，就会进行回滚（Rollback）。</p>
<p>但同样MGR也有一些缺点，在前面的文章中有对应描述</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/04/26/2023-04-04-Redis%E4%B8%96%E7%95%8C-2-client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/26/2023-04-04-Redis%E4%B8%96%E7%95%8C-2-client/" class="post-title-link" itemprop="url">2023-04-04-Redis世界-2-client</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-26 20:41:06" itemprop="dateCreated datePublished" datetime="2023-04-26T20:41:06+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-24 15:19:44" itemprop="dateModified" datetime="2023-07-24T15:19:44+08:00">2023-07-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis 是怎么接受客户端请求并且进行响应的呢？并且Redis是怎么维护客户端链接的呢？</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>Redis 基于TCP + 自定义协议实现通信和请求，因为tcp是流式的，所以对于每一个client会先将网络数据保存在querybuf当中，攒够了再处理，另外写出数据放在buf当中</p>
<p>Client数据结构比较复杂，有一些字段还和slave和replation有关，这里暂不详细看</p>
<p>一般情况下，使用TCP作为通信协议，在应用层还需要增加一层协议用于区分请求，比如定长包，固定分割符，header+content等形式，在Redis里面用了Redis serialization protocol (RESP) specification</p>
<pre><code class="c">typedef struct client &#123;
    uint64_t id;            /* Client incremental unique ID. */
    uint64_t flags;         /* Client flags: CLIENT_* macros. */
    connection *conn;
    int resp;               /* RESP protocol version. Can be 2 or 3. */
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    robj *name;             /* As set by CLIENT SETNAME. */
    sds querybuf;           /* Buffer we use to accumulate client queries. */
    size_t qb_pos;          /* The position we have read in querybuf. */
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
    int argc;               /* Num of arguments of current command. */
    robj **argv;            /* Arguments of current command. */
    int argv_len;           /* Size of argv array (may be more than argc) */
    int original_argc;      /* Num of arguments of original command if arguments were rewritten. */
    robj **original_argv;   /* Arguments of original command if arguments were rewritten. */
    size_t argv_len_sum;    /* Sum of lengths of objects in argv list. */
    struct redisCommand *cmd, *lastcmd;  /* Last command executed. */
    struct redisCommand *realcmd; /* The original command that was executed by the client,
                                     Used to update error stats in case the c-&gt;cmd was modified
                                     during the command invocation (like on GEOADD for example). */
    user *user;             /* User associated with this connection. If the
                               user is set to NULL the connection can do
                               anything (admin). */
    int reqtype;            /* Request protocol type: PROTO_REQ_* */
    int multibulklen;       /* Number of multi bulk arguments left to read. */
    long bulklen;           /* Length of bulk argument in multi bulk request. */
    list *reply;            /* List of reply objects to send to the client. */
    unsigned long long reply_bytes; /* Tot bytes of objects in reply list. */
    list *deferred_reply_errors;    /* Used for module thread safe contexts. */
    size_t sentlen;         /* Amount of bytes already sent in the current
                               buffer or object being sent. */
    time_t ctime;           /* Client creation time. */
    long duration;          /* Current command duration. Used for measuring latency of blocking/non-blocking cmds */
    int slot;               /* The slot the client is executing against. Set to -1 if no slot is being used */
    dictEntry *cur_script;  /* Cached pointer to the dictEntry of the script being executed. */
    time_t lastinteraction; /* Time of the last interaction, used for timeout */
    time_t obuf_soft_limit_reached_time;
    int authenticated;      /* Needed when the default user requires auth. */
    int replstate;          /* Replication state if this is a slave. */
    int repl_start_cmd_stream_on_ack; /* Install slave write handler on first ACK. */
    int repldbfd;           /* Replication DB file descriptor. */
    off_t repldboff;        /* Replication DB file offset. */
    off_t repldbsize;       /* Replication DB file size. */
    sds replpreamble;       /* Replication DB preamble. */
    long long read_reploff; /* Read replication offset if this is a master. */
    long long reploff;      /* Applied replication offset if this is a master. */
    long long repl_applied; /* Applied replication data count in querybuf, if this is a replica. */
    long long repl_ack_off; /* Replication ack offset, if this is a slave. */
    long long repl_ack_time;/* Replication ack time, if this is a slave. */
    long long repl_last_partial_write; /* The last time the server did a partial write from the RDB child pipe to this replica  */
    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves
                                       copying this slave output buffer
                                       should use. */
    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */
    int slave_listening_port; /* As configured with: REPLCONF listening-port */
    char *slave_addr;       /* Optionally given by REPLCONF ip-address */
    int slave_capa;         /* Slave capabilities: SLAVE_CAPA_* bitwise OR. */
    int slave_req;          /* Slave requirements: SLAVE_REQ_* */
    multiState mstate;      /* MULTI/EXEC state */
    int btype;              /* Type of blocking op if CLIENT_BLOCKED. */
    blockingState bpop;     /* blocking state */
    long long woff;         /* Last write global replication offset. */
    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */
    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */
    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */
    dict *pubsubshard_channels;  /* shard level channels a client is interested in (SSUBSCRIBE) */
    sds peerid;             /* Cached peer ID. */
    sds sockname;           /* Cached connection target address. */
    listNode *client_list_node; /* list node in client list */
    listNode *postponed_list_node; /* list node within the postponed list */
    listNode *pending_read_list_node; /* list node in clients pending read list */
    RedisModuleUserChangedFunc auth_callback; /* Module callback to execute
                                               * when the authenticated user
                                               * changes. */
    void *auth_callback_privdata; /* Private data that is passed when the auth
                                   * changed callback is executed. Opaque for
                                   * Redis Core. */
    void *auth_module;      /* The module that owns the callback, which is used
                             * to disconnect the client if the module is
                             * unloaded for cleanup. Opaque for Redis Core.*/

    /* If this client is in tracking mode and this field is non zero,
     * invalidation messages for keys fetched by this client will be send to
     * the specified client ID. */
    uint64_t client_tracking_redirection;
    rax *client_tracking_prefixes; /* A dictionary of prefixes we are already
                                      subscribed to in BCAST mode, in the
                                      context of client side caching. */
    /* In updateClientMemoryUsage() we track the memory usage of
     * each client and add it to the sum of all the clients of a given type,
     * however we need to remember what was the old contribution of each
     * client, and in which category the client was, in order to remove it
     * before adding it the new value. */
    size_t last_memory_usage;
    int last_memory_type;

    listNode *mem_usage_bucket_node;
    clientMemUsageBucket *mem_usage_bucket;

    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,
                                  * see the definition of replBufBlock. */
    size_t ref_block_pos;        /* Access position of referenced buffer block,
                                  * i.e. the next offset to send. */

    /* Response buffer */
    size_t buf_peak; /* Peak used size of buffer in last 5 sec interval. */
    mstime_t buf_peak_last_reset_time; /* keeps the last time the buffer peak value was reset */
    int bufpos;
    size_t buf_usable_size; /* Usable size of buffer. */
    char *buf;
&#125; client
</code></pre>
<h2 id="initServer-初始化"><a href="#initServer-初始化" class="headerlink" title="initServer 初始化"></a>initServer 初始化</h2><p>针对每个监听socket fd，注册读事件，处理器为acceptTcpHandler</p>
<pre><code class="c">/* Create an event handler for accepting new connections in TCP or TLS domain sockets.
 * This works atomically for all socket fds */
int createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) &#123;
    int j;

    for (j = 0; j &lt; sfd-&gt;count; j++) &#123;
        if (aeCreateFileEvent(server.el, sfd-&gt;fd[j], AE_READABLE, accept_handler, NULL) == AE_ERR) &#123;
            /* Rollback */
            for (j = j - 1; j &gt;= 0; j--) aeDeleteFileEvent(server.el, sfd-&gt;fd[j], AE_READABLE);
            return C_ERR;
        &#125;
    &#125;
    return C_OK;
&#125;
</code></pre>
<h2 id="acceptTcpHandler"><a href="#acceptTcpHandler" class="headerlink" title="acceptTcpHandler"></a>acceptTcpHandler</h2><p>对于server端的fd读事件处理，每次最多处理MAX_ACCEPTS_PER_CALL个请求,默认值是1000<br>处理过程是通过anetTcpAccept得到客户端fd(cfd),调用connCreateAcceptedSocket封装connection<br>然后调用 acceptCommonHandler 创建client对象~</p>
<pre><code class="c">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) &#123;
    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) &#123;
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);
        if (cfd == ANET_ERR) &#123;
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    &quot;Accepting client connection: %s&quot;, server.neterr);
            return;
        &#125;
        serverLog(LL_VERBOSE,&quot;Accepted %s:%d&quot;, cip, cport);
        acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip);
    &#125;
&#125;
</code></pre>
<p>创建client对象的过程中会调用connSetReadHandler，注册对该client fd的读事件监听</p>
<pre><code class="c">client *createClient(connection *conn) &#123;
    client *c = zmalloc(sizeof(client));

    /* passing NULL as conn it is possible to create a non connected client.
     * This is useful since all the commands needs to be executed
     * in the context of a client. When commands are executed in other
     * contexts (for instance a Lua script) we need a non connected client. */
    if (conn) &#123;
        connEnableTcpNoDelay(conn);
        if (server.tcpkeepalive)
            connKeepAlive(conn,server.tcpkeepalive);
        connSetReadHandler(conn, readQueryFromClient);
        connSetPrivateData(conn, c);
    &#125;
    c-&gt;buf = zmalloc(PROTO_REPLY_CHUNK_BYTES);
    selectDb(c,0);
    uint64_t client_id;
    atomicGetIncr(server.next_client_id, client_id, 1);
    c-&gt;id = client_id;
    c-&gt;resp = 2;
    c-&gt;conn = conn;
    c-&gt;name = NULL;
    c-&gt;bufpos = 0;
    c-&gt;buf_usable_size = zmalloc_usable_size(c-&gt;buf);
    c-&gt;buf_peak = c-&gt;buf_usable_size;
    c-&gt;buf_peak_last_reset_time = server.unixtime;
    c-&gt;ref_repl_buf_node = NULL;
    c-&gt;ref_block_pos = 0;
    c-&gt;qb_pos = 0;
    c-&gt;querybuf = sdsempty();
    c-&gt;querybuf_peak = 0;
    c-&gt;reqtype = 0;
    c-&gt;argc = 0;
    c-&gt;argv = NULL;
    c-&gt;argv_len = 0;
    c-&gt;argv_len_sum = 0;
    c-&gt;original_argc = 0;
    c-&gt;original_argv = NULL;
    c-&gt;cmd = c-&gt;lastcmd = c-&gt;realcmd = NULL;
    c-&gt;cur_script = NULL;
    c-&gt;multibulklen = 0;
    c-&gt;bulklen = -1;
    c-&gt;sentlen = 0;
    c-&gt;flags = 0;
    c-&gt;slot = -1;
    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;
    clientSetDefaultAuth(c);
    c-&gt;replstate = REPL_STATE_NONE;
    c-&gt;repl_start_cmd_stream_on_ack = 0;
    c-&gt;reploff = 0;
    c-&gt;read_reploff = 0;
    c-&gt;repl_applied = 0;
    c-&gt;repl_ack_off = 0;
    c-&gt;repl_ack_time = 0;
    c-&gt;repl_last_partial_write = 0;
    c-&gt;slave_listening_port = 0;
    c-&gt;slave_addr = NULL;
    c-&gt;slave_capa = SLAVE_CAPA_NONE;
    c-&gt;slave_req = SLAVE_REQ_NONE;
    c-&gt;reply = listCreate();
    c-&gt;deferred_reply_errors = NULL;
    c-&gt;reply_bytes = 0;
    c-&gt;obuf_soft_limit_reached_time = 0;
    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);
    listSetDupMethod(c-&gt;reply,dupClientReplyValue);
    c-&gt;btype = BLOCKED_NONE;
    c-&gt;bpop.timeout = 0;
    c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType);
    c-&gt;bpop.target = NULL;
    c-&gt;bpop.xread_group = NULL;
    c-&gt;bpop.xread_consumer = NULL;
    c-&gt;bpop.xread_group_noack = 0;
    c-&gt;bpop.numreplicas = 0;
    c-&gt;bpop.reploffset = 0;
    c-&gt;woff = 0;
    c-&gt;watched_keys = listCreate();
    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType);
    c-&gt;pubsub_patterns = listCreate();
    c-&gt;pubsubshard_channels = dictCreate(&amp;objectKeyPointerValueDictType);
    c-&gt;peerid = NULL;
    c-&gt;sockname = NULL;
    c-&gt;client_list_node = NULL;
    c-&gt;postponed_list_node = NULL;
    c-&gt;pending_read_list_node = NULL;
    c-&gt;client_tracking_redirection = 0;
    c-&gt;client_tracking_prefixes = NULL;
    c-&gt;last_memory_usage = 0;
    c-&gt;last_memory_type = CLIENT_TYPE_NORMAL;
    c-&gt;auth_callback = NULL;
    c-&gt;auth_callback_privdata = NULL;
    c-&gt;auth_module = NULL;
    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);
    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);
    c-&gt;mem_usage_bucket = NULL;
    c-&gt;mem_usage_bucket_node = NULL;
    if (conn) linkClient(c);
    initClientMultiState(c);
    return c;
&#125;
</code></pre>
<p>实际注册监听读事件在 connSocketSetReadHandler，回调函数绑定ae_handler，对应的实现是aconnSocketEventHandle,是通用响应器</p>
<p>该处理器会判断具体的读写事件分发调用 read_handler write_handler</p>
<pre><code class="c">/* Register a read handler, to be called when the connection is readable.
 * If NULL, the existing handler is removed.
 */
static int connSocketSetReadHandler(connection *conn, ConnectionCallbackFunc func) &#123;
    if (func == conn-&gt;read_handler) return C_OK;

    conn-&gt;read_handler = func;
    if (!conn-&gt;read_handler)
        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_READABLE);
    else
        if (aeCreateFileEvent(server.el,conn-&gt;fd,
                    AE_READABLE,conn-&gt;type-&gt;ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
&#125;
</code></pre>
<h2 id="readHandler-readQueryFromClient"><a href="#readHandler-readQueryFromClient" class="headerlink" title="readHandler - readQueryFromClient"></a>readHandler - readQueryFromClient</h2><p>该函数是Redis中用于读取客户端发来的请求并进行处理的函数，函数的主要流程如下：</p>
<ol>
<li><p>判断是否需要推迟从客户端读取数据的操作，如果该客户端的请求是多条bulk的请求，并且正在处理的bulk请求过大时，采用非贪心方式扩展querybuf空间以避免复制缓冲区提高性能。</p>
</li>
<li><p>因为queryBuf是需要动态扩展的，所以当querybuf长度不够时需要对querybuf进行空间扩展，如果该客户端是一个master客户端，querybuf的扩展可采用贪心方式；否则采用非贪心方式，避免与RESIZE_THRESHOLD机制产生干扰。所谓贪心与非贪心则是，非贪心仅扩展到刚好的内存，贪心则是类似扩充到目前内存的两倍，可能会有一定额外的内存</p>
</li>
<li><p>从socket中读取请求数据并添加到querybuf缓冲区中如果querybuf缓冲区已满，则关闭该客户端连接并释放该客户端所占用的资源。</p>
</li>
<li><p>维护相关计数器并更新客户端的最后操作时间。</p>
</li>
</ol>
<pre><code class="c">void readQueryFromClient(connection *conn) &#123;
    client *c = connGetPrivateData(conn);
    int nread, big_arg = 0;
    size_t qblen, readlen;

    /* Check if we want to read from the client later when exiting from
     * the event loop. This is the case if threaded I/O is enabled. */
    if (postponeClientRead(c)) return;

    /* Update total number of reads on server */
    atomicIncr(server.stat_total_reads_processed, 1);

    readlen = PROTO_IOBUF_LEN;
    /* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */
    if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1
        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)
    &#123;
        ssize_t remaining = (size_t)(c-&gt;bulklen+2)-(sdslen(c-&gt;querybuf)-c-&gt;qb_pos);
        big_arg = 1;

        /* Note that the &#39;remaining&#39; variable may be zero in some edge case,
         * for example once we resume a blocked client after CLIENT PAUSE. */
        if (remaining &gt; 0) readlen = remaining;

        /* Master client needs expand the readlen when meet BIG_ARG(see #9100),
         * but doesn&#39;t need align to the next arg, we can read more data. */
        if (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; readlen &lt; PROTO_IOBUF_LEN)
            readlen = PROTO_IOBUF_LEN;
    &#125;

    qblen = sdslen(c-&gt;querybuf);
    if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; // master client&#39;s querybuf can grow greedy.
        (big_arg || sdsalloc(c-&gt;querybuf) &lt; PROTO_IOBUF_LEN)) &#123;
        /* When reading a BIG_ARG we won&#39;t be reading more than that one arg
         * into the query buffer, so we don&#39;t need to pre-allocate more than we
         * need, so using the non-greedy growing. For an initial allocation of
         * the query buffer, we also don&#39;t wanna use the greedy growth, in order
         * to avoid collision with the RESIZE_THRESHOLD mechanism. */
        c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, readlen);
    &#125; else &#123;
        c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);

        /* Read as much as possible from the socket to save read(2) system calls. */
        readlen = sdsavail(c-&gt;querybuf);
    &#125;
    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen);
    if (nread == -1) &#123;
        if (connGetState(conn) == CONN_STATE_CONNECTED) &#123;
            return;
        &#125; else &#123;
            serverLog(LL_VERBOSE, &quot;Reading from client: %s&quot;,connGetLastError(c-&gt;conn));
            freeClientAsync(c);
            goto done;
        &#125;
    &#125; else if (nread == 0) &#123;
        if (server.verbosity &lt;= LL_VERBOSE) &#123;
            sds info = catClientInfoString(sdsempty(), c);
            serverLog(LL_VERBOSE, &quot;Client closed connection %s&quot;, info);
            sdsfree(info);
        &#125;
        freeClientAsync(c);
        goto done;
    &#125;

    sdsIncrLen(c-&gt;querybuf,nread);
    qblen = sdslen(c-&gt;querybuf);
    if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;

    c-&gt;lastinteraction = server.unixtime;
    if (c-&gt;flags &amp; CLIENT_MASTER) &#123;
        c-&gt;read_reploff += nread;
        atomicIncr(server.stat_net_repl_input_bytes, nread);
    &#125; else &#123;
        atomicIncr(server.stat_net_input_bytes, nread);
    &#125;

    if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;
        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();

        bytes = sdscatrepr(bytes,c-&gt;querybuf,64);
        serverLog(LL_WARNING,&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;, ci, bytes);
        sdsfree(ci);
        sdsfree(bytes);
        freeClientAsync(c);
        goto done;
    &#125;

    /* There is more data in the client input buffer, continue parsing it
     * and check if there is a full command to execute. */
    if (processInputBuffer(c) == C_ERR)
         c = NULL;

done:
    beforeNextClient(c);
&#125;
</code></pre>
<h3 id="processInputBuffer"><a href="#processInputBuffer" class="headerlink" title="processInputBuffer"></a>processInputBuffer</h3><p>redis从网络中读到数据后，就会按照RESP协议得到当前客户端的命令和值，解析详情请看RESP协议解读</p>
<p>以set key value 命令举例，经过resp协议编码将会得到</p>
<p><img src="/2023/04/26/2023-04-04-Redis%E4%B8%96%E7%95%8C-2-client/resp.png"></p>
<p>通过协议解析后，调用processCommandAndResetClient执行实际命令，先从根据 c-&gt;argv,c-&gt;argc，从server.command中找到对应的命令。</p>
<p>server.command是一个redis dict结构，保存着命令相关的执行方法，复杂度，提示信息等各项内容,如图所示</p>
<div><div class="graphviz">digraph g {
    fontname = "Helvetica,Arial,sans-serif";
    node [fontname = "Helvetica,Arial,sans-serif";];
    edge [fontname = "Helvetica,Arial,sans-serif";];
    graph [rankdir = "LR";];
    node [shape = "ellipse";];
    
<pre><code>&quot;redisServer&quot; [label = &quot;redis.server|commands|....&quot;;shape = &quot;record&quot;;];

&quot;commands&quot; [label = &quot; &lt;f1&gt; hset|&lt;f2&gt; hget |&lt;f3&gt; hdel |&lt;f4&gt; otherCommand&quot;;shape = &quot;record&quot;;];

&quot;hset&quot; [label = &quot;name:hset | summary:GSet the string value of a hash field| .proc : hsetCommand | ...&quot;;shape = &quot;record&quot;;];

&quot;hget&quot; [label = &quot;name:hset summary:Get the value of a hash field | .proc: hgetComand | ...&quot;;shape = &quot;record&quot;;];
&quot;otherCommand&quot; [label = &quot;...&quot;;shape = &quot;record&quot;;];
&quot;redisServer&quot; -&gt; &quot;commands&quot;;
&quot;commands&quot;:f1 -&gt; &quot;hset&quot;;
&quot;commands&quot;:f2 -&gt; &quot;hget&quot;;
&quot;commands&quot;:f4 -&gt; otherCommand;
</code></pre>
<p>}</div></div></p>
<p>在dict到找到相关命令后，然后执行对应命令的函数</p>
<p>执行前还有不少其他逻辑，比如</p>
<ol>
<li>校验参数个数是否正确</li>
<li>校验调用者权限</li>
<li>判断是否开启了cluster配置，发起调用转向</li>
<li>最大内存使用量判断</li>
<li>….</li>
</ol>
<pre><code class="c">struct redisCommand *lookupCommand(robj **argv, int argc) &#123;
    return lookupCommandLogic(server.commands, argv, argc, 0);
&#125;

struct redisCommand *lookupCommandLogic(dict *commands, robj **argv, int argc, int strict) &#123;
    struct redisCommand *base_cmd = dictFetchValue(commands, argv[0]-&gt;ptr);
    int has_subcommands = base_cmd &amp;&amp; base_cmd-&gt;subcommands_dict;
    if (argc == 1 || !has_subcommands) &#123;
        if (strict &amp;&amp; argc != 1)
            return NULL;
        /* Note: It is possible that base_cmd-&gt;proc==NULL (e.g. CONFIG) */
        return base_cmd;
    &#125; else &#123; /* argc &gt; 1 &amp;&amp; has_subcommands */
        if (strict &amp;&amp; argc != 2)
            return NULL;
        /* Note: Currently we support just one level of subcommands */
        return lookupSubcommand(base_cmd, argv[1]-&gt;ptr);
    &#125;
&#125;
</code></pre>
<p>执行对应的command</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/04/04/2023-04-04-Redis%E4%B8%96%E7%95%8C-1-eventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/04/2023-04-04-Redis%E4%B8%96%E7%95%8C-1-eventLoop/" class="post-title-link" itemprop="url">2023-04-04-Redis世界-1-eventLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-04 18:15:34" itemprop="dateCreated datePublished" datetime="2023-04-04T18:15:34+08:00">2023-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-26 20:50:53" itemprop="dateModified" datetime="2023-04-26T20:50:53+08:00">2023-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看之前redis设计与实现、还有网上解析的文章，大部分都聚焦在redis的数据结构的实现，其实也了解一下redis的事件设计，更好的了解redis的处理过程</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>server.c</p>
<p>main流程</p>
<ol>
<li>各种server的初始化</li>
<li>aeMain(server.el) 循环处理事件</li>
</ol>
<p>其中aeMain就是主线程不断处理事件的函数，入参是个EventLoop，当EventLoop不是终止状态的时候，循环处理Events,aeProcessEvents的第二个参数就是代表本次要处理的时间类型</p>
<pre><code class="c">
int main()&#123;
    //init

    aeMain(server.el);
    aeDeleteEventLoop(server.el);
    return 0;
&#125;

void aeMain(aeEventLoop *eventLoop) &#123;
    eventLoop-&gt;stop = 0;
    while (!eventLoop-&gt;stop) &#123;
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    &#125;
&#125;
</code></pre>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop 的事件分类</p>
<ul>
<li>fileEvent :  网络io (epoll&#x2F;kqueue 事件)</li>
<li>timeEvent : 定时任务&#x2F;延迟任务类的</li>
</ul>
<p>EventLoop定义事件如下</p>
<pre><code class="c">/* State of an event based program */
typedef struct aeEventLoop &#123;
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
&#125; aeEventLoop;
</code></pre>
<p>在redisServer初始化的时候创建,入参是事件队列的大小，默认是 server.maxclients + RESERVED_FDS + 一定冗余空间，<br>然后创建fired,events数组列表，timeEvent结构是链表形式的</p>
<pre><code class="c">aeEventLoop *aeCreateEventLoop(int setsize) &#123;
    aeEventLoop *eventLoop;
    int i;

    monotonicInit();    /* just in case the calling app didn&#39;t initialize */

    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;
    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);
    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fered == NULL) goto err;
    eventLoop-&gt;setsize = setsize;
    eventLoop-&gt;timeEventHead = NULL;
    eventLoop-&gt;timeEventNextId = 0;
    eventLoop-&gt;stop = 0;
    eventLoop-&gt;maxfd = -1;
    eventLoop-&gt;beforesleep = NULL;
    eventLoop-&gt;aftersleep = NULL;
    eventLoop-&gt;flags = 0;
    if (aeApiCreate(eventLoop) == -1) goto err;
    /* Events with mask == AE_NONE are not set. So let&#39;s initialize the
     * vector with it. */
    for (i = 0; i &lt; setsize; i++)
        eventLoop-&gt;events[i].mask = AE_NONE;
    return eventLoop;

err:
    if (eventLoop) &#123;
        zfree(eventLoop-&gt;events);
        zfree(eventLoop-&gt;fired);
        zfree(eventLoop);
    &#125;
    return NULL;b
&#125;
</code></pre>
<h3 id="ApiEvent"><a href="#ApiEvent" class="headerlink" title="ApiEvent"></a>ApiEvent</h3><p>可以看到redis的事件管理兼容不同平台的实现，比如epoll，kqueue</p>
<p>完成不同的aeApiCreate实现</p>
<pre><code class="c">/* Include the best multiplexing layer supported by this system.
 * The following should be ordered by performances, descending. */
#ifdef HAVE_EVPORT
#include &quot;ae_evport.c&quot;
#else
    #ifdef HAVE_EPOLL
    #include &quot;ae_epoll.c&quot;
    #else
        #ifdef HAVE_KQUEUE
        #include &quot;ae_kqueue.c&quot;
        #else
        #include &quot;ae_select.c&quot;
        #endif
    #endif
#endif

// 以 linux epoll 为例，创建过程将epoll_event 记录在apiState数据结构当中
typedef struct aeApiState &#123;
    int epfd;
    struct epoll_event *events;
&#125; aeApiState;

static int aeApiCreate(aeEventLoop *eventLoop) &#123;
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize);
    if (!state-&gt;events) &#123;
        zfree(state);
        return -1;
    &#125;
    state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
    if (state-&gt;epfd == -1) &#123;
        zfree(state-&gt;events);
        zfree(state);
        return -1;
    &#125;
    anetCloexec(state-&gt;epfd);
    eventLoop-&gt;apidata = state;
    return 0;
&#125;
</code></pre>
<p>poll过程，将epoll返回的事件封装处理，放入fired队列</p>
<pre><code class="c">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;
    aeApiState *state = eventLoop-&gt;apidata;
    int retval, numevents = 0;

    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,
            tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1);
    if (retval &gt; 0) &#123;
        int j;

        numevents = retval;
        for (j = 0; j &lt; numevents; j++) &#123;
            int mask = 0;
            struct epoll_event *e = state-&gt;events+j;

            if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;
            if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;
            if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE;
            if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE;
            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;
            eventLoop-&gt;fired[j].mask = mask;
        &#125;
    &#125; else if (retval == -1 &amp;&amp; errno != EINTR) &#123;
        panic(&quot;aeApiPoll: epoll_wait, %s&quot;, strerror(errno));
    &#125;

    return numevents;
&#125;
</code></pre>
<p>mask是一个int类型，用于位计算标识事件类型，位计算1，2，4，8没什么好说的了~</p>
<pre><code class="c">#define AE_NONE 0       /* No events registered. */
#define AE_READABLE 1   /* Fire when descriptor is readable. */
#define AE_WRITABLE 2   /* Fire when descriptor is writable. */
#define AE_BARRIER 4    /* With WRITABLE, never fire the event if the
                           READABLE event already fired in the same event
                           loop iteration. Useful when you want to persist
                           things to disk before sending replies, and want
                           to do that in a group fashion. */
</code></pre>
<h3 id="FileEvent"><a href="#FileEvent" class="headerlink" title="FileEvent"></a>FileEvent</h3><p>主要是处理网络事件，针对各平台的时间进行了一层抽象,fileEvent的数组坐标是直接用的fd，可以看到aeCreateFileEvent的的过程中还是通过aeApiAddEvent完成注册绑定的</p>
<pre><code class="c">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
&#123;
    if (fd &gt;= eventLoop-&gt;setsize) &#123;
        errno = ERANGE;
        return AE_ERR;
    &#125;
    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];

    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
        return AE_ERR;
    fe-&gt;mask |= mask;
    if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;
    if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;
    fe-&gt;clientData = clientData;
    if (fd &gt; eventLoop-&gt;maxfd)
        eventLoop-&gt;maxfd = fd;
    return AE_OK;
&#125;

void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
&#123;
    if (fd &gt;= eventLoop-&gt;setsize) return;
    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];
    if (fe-&gt;mask == AE_NONE) return;

    /* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */
    if (mask &amp; AE_WRITABLE) mask |= AE_BARRIER;

    aeApiDelEvent(eventLoop, fd, mask);
    fe-&gt;mask = fe-&gt;mask &amp; (~mask);
    if (fd == eventLoop-&gt;maxfd &amp;&amp; fe-&gt;mask == AE_NONE) &#123;
        /* Update the max fd */
        int j;

        for (j = eventLoop-&gt;maxfd-1; j &gt;= 0; j--)
            if (eventLoop-&gt;events[j].mask != AE_NONE) break;
        eventLoop-&gt;maxfd = j;
    &#125;
&#125;
</code></pre>
<p>文件事件处理过程,这部分代码就是事件循环处理的核心逻辑了，总得来说通过apipoll获得触发的事件个数，然后遍历fired列表取出对应的fd，并根据事件类型进行对应的事件调用。</p>
<p>此外的点:</p>
<ol>
<li>poll中阻塞的时间怎么计算，如果没有配置AE_DONT_WAIT参数，则根据aeTimeEvent列表中取得一个最近的时间事件，通过计算now-when得到阻塞唤醒的时间</li>
<li>在调用apiPoll 会有before sleep 和 after sleep的钩子，用于完成一些其他功能调用，这些放在后面再看</li>
<li>通常redis会先处理读事件，才处理写事件，这样做的好处是，有时会在处理查询后立即完成响应，因此在可读事件后面执行可写事件更合理一些。但如果该事件设置了AE_BARRIER，在这种情况下，将会反转调用顺序，先执行读事件，再执行写时间。这是有用的情况之一是在 beforeSleep() 中做一些事情，例如在对客户端进行响应之前，要将一个文件同步到磁盘上，则先处理读事件</li>
</ol>
<pre><code class="c">int aeProcessEvents(aeEventLoop *eventLoop, int flags)
&#123;
    int processed = 0, numevents;

    /* Nothing to do? return ASAP */
    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;

    /* Note that we want to call select() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */
    //也就是poll的等待时间，是根据usUntilEarliestTimer计算出来的
    if (eventLoop-&gt;maxfd != -1 ||
        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;
        int j;
        struct timeval tv, *tvp;
        int64_t usUntilTimer = -1;

        if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))
            usUntilTimer = usUntilEarliestTimer(eventLoop);

        if (usUntilTimer &gt;= 0) &#123;
            tv.tv_sec = usUntilTimer / 1000000;
            tv.tv_usec = usUntilTimer % 1000000;
            tvp = &amp;tv;
        &#125; else &#123;
            /* If we have to check for events but need to return
             * ASAP because of AE_DONT_WAIT we need to set the timeout
             * to zero */
            if (flags &amp; AE_DONT_WAIT) &#123;
                tv.tv_sec = tv.tv_usec = 0;
                tvp = &amp;tv;
            &#125; else &#123;
                /* Otherwise we can block */
                tvp = NULL; /* wait forever */
            &#125;
        &#125;

        if (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;
            tv.tv_sec = tv.tv_usec = 0;
            tvp = &amp;tv;
        &#125;

        if (eventLoop-&gt;beforesleep != NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)
            eventLoop-&gt;beforesleep(eventLoop);

        /* Call the multiplexing API, will return only on timeout or when
         * some event fires. */
        numevents = aeApiPoll(eventLoop, tvp);

        /* After sleep callback. */
        if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)
            eventLoop-&gt;aftersleep(eventLoop);

        for (j = 0; j &lt; numevents; j++) &#123;
            int fd = eventLoop-&gt;fired[j].fd;
            aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];
            int mask = eventLoop-&gt;fired[j].mask;
            int fired = 0; /* Number of events fired for current fd. */

            /* Normally we execute the readable event first, and the writable
             * event later. This is useful as sometimes we may be able
             * to serve the reply of a query immediately after processing the
             * query.
             *
             * However if AE_BARRIER is set in the mask, our application is
             * asking us to do the reverse: never fire the writable event
             * after the readable. In such a case, we invert the calls.
             * This is useful when, for instance, we want to do things
             * in the beforeSleep() hook, like fsyncing a file to disk,
             * before replying to a client. */
            int invert = fe-&gt;mask &amp; AE_BARRIER;

            /* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already
             * processed event removed an element that fired and we still
             * didn&#39;t processed, so we check if the event is still valid.
             *
             * Fire the readable event if the call sequence is not
             * inverted. */
            if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;
                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                fired++;
                fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */
            &#125;

            /* Fire the writable event. */
            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;
                if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;
                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                    fired++;
                &#125;
            &#125;

            /* If we have to invert the call, fire the readable event now
             * after the writable one. */
            if (invert) &#123;
                fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */
                if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;
                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc))
                &#123;
                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                    fired++;
                &#125;
            &#125;

            processed++;
        &#125;
    &#125;
    /* Check time events */
    if (flags &amp; AE_TIME_EVENTS)
        processed += processTimeEvents(eventLoop);

    return processed; /* return the number of processed file/time events */
</code></pre>
<h3 id="TimeEvent"><a href="#TimeEvent" class="headerlink" title="TimeEvent"></a>TimeEvent</h3><p>是redis管理时间事件的，比如定时任务、延时任务，就是定时器实现，</p>
<p>创建过程比较简单，用一个递增数字标识id，获取一下任务的执行时间放在when字段中，proc绑定定时任务的函数，然后用头插法插入链表头部</p>
<p>删除过程就是遍历链表，将链表id置为-1，直到线程处理时间事件的时候才进行链表的修改</p>
<pre><code class="c">long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc)
&#123;
    long long id = eventLoop-&gt;timeEventNextId++;
    aeTimeEvent *te;

    te = zmalloc(sizeof(*te));
    if (te == NULL) return AE_ERR;
    te-&gt;id = id;
    te-&gt;when = getMonotonicUs() + milliseconds * 1000;
    te-&gt;timeProc = proc;
    te-&gt;finalizerProc = finalizerProc;
    te-&gt;clientData = clientData;
    te-&gt;prev = NULL;
    te-&gt;next = eventLoop-&gt;timeEventHead;
    te-&gt;refcount = 0;
    if (te-&gt;next)
        te-&gt;next-&gt;prev = te;
    eventLoop-&gt;timeEventHead = te;
    return id;
&#125;

int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
&#123;
    aeTimeEvent *te = eventLoop-&gt;timeEventHead;
    while(te) &#123;
        if (te-&gt;id == id) &#123;
            te-&gt;id = AE_DELETED_EVENT_ID;
            return AE_OK;
        &#125;
        te = te-&gt;next;
    &#125;
    return AE_ERR; /* NO event with the specified ID found */
&#125;
</code></pre>
<p>定时器的执行过程，遍历链表，判断当前节点的id是不是delete id(-1),是的话就执行链表删除操作</p>
<p>至于其他时间器实现就更简单了，也不涉及优先队列时间轮，直接遍历判断当前时间是否超过when了，超过了就执行….<br>执行完了根据返回值看是否还要执行下一次，如果返回值大于零，修改when时间，代表的还有下一次执行，否则的话将id修改为0就完事~</p>
<p>在initServer()中添加了几个事件，其中包含一个时间事件——serverCron。 serverCron以每秒server.hz次数执行 功能比如：</p>
<ol>
<li>驱逐过期的key</li>
<li>客户端超时</li>
<li>信息统计</li>
<li>rehash hashtables</li>
<li>BGSAVE AOF</li>
<li>从库重连</li>
<li>..其他工作</li>
</ol>
<pre><code class="c">/* Process time events */
static int processTimeEvents(aeEventLoop *eventLoop) &#123;
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;

    te = eventLoop-&gt;timeEventHead;
    maxId = eventLoop-&gt;timeEventNextId-1;
    monotime now = getMonotonicUs();
    while(te) &#123;
        long long id;

        /* Remove events scheduled for deletion. */
        if (te-&gt;id == AE_DELETED_EVENT_ID) &#123;
            aeTimeEvent *next = te-&gt;next;
            /* If a reference exists for this timer event,
             * don&#39;t free it. This is currently incremented
             * for recursive timerProc calls */
            if (te-&gt;refcount) &#123;
                te = next;
                continue;
            &#125;
            if (te-&gt;prev)
                te-&gt;prev-&gt;next = te-&gt;next;
            else
                eventLoop-&gt;timeEventHead = te-&gt;next;
            if (te-&gt;next)
                te-&gt;next-&gt;prev = te-&gt;prev;
            if (te-&gt;finalizerProc) &#123;
                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);
                now = getMonotonicUs();
            &#125;
            zfree(te);
            te = next;
            continue;
        &#125;

        /* Make sure we don&#39;t process time events created by time events in
         * this iteration. Note that this check is currently useless: we always
         * add new timers on the head, however if we change the implementation
         * detail, this check may be useful again: we keep it here for future
         * defense. */
        if (te-&gt;id &gt; maxId) &#123;
            te = te-&gt;next;
            continue;
        &#125;

        if (te-&gt;when &lt;= now) &#123;
            int retval;

            id = te-&gt;id;
            te-&gt;refcount++;
            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);
            te-&gt;refcount--;
            processed++;
            now = getMonotonicUs();
            if (retval != AE_NOMORE) &#123;
                te-&gt;when = now + retval * 1000;
            &#125; else &#123;
                te-&gt;id = AE_DELETED_EVENT_ID;
            &#125;
        &#125;
        te = te-&gt;next;
    &#125;
    return processed;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/03/19/2023-03-19-redis%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/19/2023-03-19-redis%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">2023-03-19-redis 集群高可用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-19 18:22:00" itemprop="dateCreated datePublished" datetime="2023-03-19T18:22:00+08:00">2023-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-20 19:17:51" itemprop="dateModified" datetime="2023-03-20T19:17:51+08:00">2023-03-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-集群"><a href="#redis-集群" class="headerlink" title="redis 集群"></a>redis 集群</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>通过分片进行数据管理，提供复制和故障转移</p>
<p>去中心化，分槽16634一个，每个节点负责部分槽位数据，每个集群是对等的，通过gossip协议交互集群信息，最后每个节点保存其他节点的slots</p>
<h2 id="什么是gossip协议"><a href="#什么是gossip协议" class="headerlink" title="什么是gossip协议"></a>什么是gossip协议</h2><blockquote>
<p>在一个处于有界网络的集群里，如果每个节点都随机与其他节点交换特定信息，经过足够长的时间后，集群各个节点对该份信息的认知终将收敛到一致。</p>
</blockquote>
<p>这里的“特定信息”一般就是指集群状态、各节点的状态以及其他元数据等。Gossip协议是完全符合 BASE 原则，可以用在任何要求最终一致性的领域，比如分布式存储和注册中心。另外，它可以很方便地实现弹性集群，允许节点随时上下线，提供快捷的失败检测和动态负载均衡等。</p>
<p>此外，Gossip 协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许 Redis Cluster 或者 Consul 集群管理的节点规模能横向扩展到数千个。</p>
<h2 id="故障协议"><a href="#故障协议" class="headerlink" title="故障协议"></a>故障协议</h2><p>Redis 集群节点采用 Gossip 协议来广播自己的状态以及自己对整个集群认知的改变。比如一个节点发现某个节点失联了 (PFail)，它会将这条信息向整个集群广播，其它节点也就可以收到这点失联信息。<br>如果一个节点收到了某个节点失联的数量 (PFail Count) 已经达到了集群的大多数，就可以标记该节点为确定下线状态 (Fail)，然后向整个集群广播，强迫其它节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。<br>当一个 Slave 发现自己的主节点进入已下线状态后，从节点将开始对下线的主节点进行故障转移。</p>
<p>1、从下线的 Master 及节点的 Slave 节点列表选择一个节点成为新主节点。<br>2、新主节点会撤销所有对已下线主节点的 slot 指派，并将这些 slots 指派给自己。<br>3、新的主节点向集群广播一条 PONG 消息，这条 PONG 消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。<br>4、新的主节点开始接收处理槽有关的命令请求，故障转移完成。</p>
<h3 id="检测过程"><a href="#检测过程" class="headerlink" title="检测过程"></a>检测过程</h3><ol>
<li>Redis Cluster 中的节点会定期检查已经发送 PING 消息的接收方节点是否在规定时间 ( cluster-node-timeout ) 内返回了 PONG 消息，如果没有则会将其标记为疑似下线状态，也就是 PFAIL 状态</li>
<li>将疑似下线状态的信息传递给其他节点，其他节点将该节点也标记为疑似下线</li>
<li>随着时间的推移，如果节点十 (举个例子) 也因为 PONG 超时而认为节点二疑似下线了，并且发现自己维护的节点二的 clusterNode 的 fail_reports 中有半数以上的主节点数量的未过时的将节点二标记为 PFAIL 状态报告日志，那么节点十将会把节点二将被标记为已下线 FAIL 状态，并且节点十会立刻向集群其他节点广播主节点二已经下线的 FAIL 消息，所有收到 FAIL 消息的节点都会立即将节点二状态标记为已下线</li>
<li>如果超过 cluster-node-timeout *2 的时间，这个报告就会被忽略掉，让节点二又恢复成正常状态。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/03/14/2023-03-14-%E4%B8%80%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/2023-03-14-%E4%B8%80%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2023-03-14-一些系统设计问题的总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-14 09:48:28 / Modified: 09:48:51" itemprop="dateCreated datePublished" datetime="2023-03-14T09:48:28+08:00">2023-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>短链系统的设计</p>
<ol>
<li>本质上是生成映射关系，一个长链对应到一个短链，那就看短链的生成方式是什么</li>
</ol>
<ul>
<li>hash，存在hash碰撞的问题，解决方法一般是重复hash，找到一个不碰撞的值，查库的话总是存在瓶颈啊，可以用布隆过滤器优化，查看生成的短链是否在数据库表记录中，用布隆过滤器的好处占用内存少</li>
<li>可以使用生成id的方式，一般都是用分布式id生成<br>  简单的自增主键<br>  redis<br>  snowflake<ul>
<li>时钟回退问题，生成id有毫秒时间戳，所以可能导致某个生成的id会重复</li>
<li><ul>
<li>进程重启+时间回拨 加入时钟版本号，进程重启的时候</li>
</ul>
</li>
<li><ul>
<li>引入zk，解决workid和时间戳</li>
</ul>
</li>
<li><ul>
<li>非技术手段，一般硬件支持NTP，但也会造成秒级回退，一般是运维场景解决<br>uuid</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>怎么设计一个红包系统？春晚抢红包和日常抢红包</p>
<p>秒杀系统支持<br>方法上来讲<br>1）快慢分离；</p>
<ul>
<li>现金和礼券后端的系统完全不同，现金通过 QQ 钱包系统发放入财付通账户，要求实时到账不能延迟。而礼券对接的后端业务千差万别，服务容量和性能各不相同。为了不让慢速的礼券发放影响快速的现金发放，将现金通道与礼券通道分离，互不干扰。<br>2）异步削峰；<br>3）柔性处理；<br>4）保护业务系统；<br>5）最终一致性。<br>如果多次发货仍然失败，对账工具第 2 天会从流水系统中将用户抽奖数据与发货数据进行对账，对发货异常用户再次发起发货。如果对账仍然失败，则提醒管理人员介入处理。</li>
</ul>
<p>redis hotkey是什么？有哪些影响？怎么解决<br>slot 模式，热key集中在某几台机器<br>监控 - 热key发现<br>优化 - 一般是二级缓存(本地缓存)<br>多级key - </p>
<p>大key是什么？有哪些影响？怎么解决</p>
<p>大文件断点续传？</p>
<p>mysql 半同步复制退化到异步复制？<br>ack超时的时候，强一致场景不能容忍</p>
<p>写扩散读扩散是什么？<br>一般用于feed流项目，比如朋友圈，好友关系关注之类的，数据写一份还是写多份</p>
<h2 id="腾讯抽奖系统学习"><a href="#腾讯抽奖系统学习" class="headerlink" title="腾讯抽奖系统学习"></a>腾讯抽奖系统学习</h2><p>抽奖系统作为 QQ 红包的核心系统，在承接用户抽奖请求，按设计合理的几率完成抽奖操作，将抽奖结果安全落地保存，并顺利发货等过程中，起到了关键作用。面对海量抽奖请求，如何及时作出响应，是抽奖系统面临的难题。</p>
<p>1）在接入层采用一致性 Hash 算法：同一用户的抽奖请求只会转发到相同的抽奖系统处理 ;<br>2）抽奖系统采用缓存机制：在加快抽奖过程的同时也减少了对存储层的访问压力；<br>3）奖品配额机制：平滑抽奖过程，各类奖品按比例有序抽中；<br>4）流水和对账机制：保证抽奖数据最终无差错发放到用户账户中。</p>
<p>缓存，很重要，如何提升缓存命中率，一般使用一致性hash算法</p>
<p>流水系统 记账对账</p>
<h2 id="双buffer-无锁切换"><a href="#双buffer-无锁切换" class="headerlink" title="双buffer 无锁切换"></a>双buffer 无锁切换</h2><p>一写一读的场景，可以实现目标，属于空间换时间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/03/02/2023-03-02-java%E5%B8%B8%E7%94%A8%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/2023-03-02-java%E5%B8%B8%E7%94%A8%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">2023-03-02-java常用启动参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 18:17:07 / Modified: 18:18:18" itemprop="dateCreated datePublished" datetime="2023-03-02T18:17:07+08:00">2023-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x2F;usr&#x2F;local&#x2F;java8&#x2F;bin&#x2F;java -server -Dfile.encoding&#x3D;UTF-8 -Dsun.jnu.encoding&#x3D;UTF-8 -Djava.io.tmpdir&#x3D;&#x2F;tmp -Djava.net.preferIPv6Addresses&#x3D;false -Djava.io.tmpdir&#x3D;&#x2F;tmp -Duser.timezone&#x3D;GMT+08 -Xss512k -Xmx4096m -Xms4096m -XX:MetaspaceSize&#x3D;512m -XX:MaxMetaspaceSize&#x3D;512m -XX:+AlwaysPreTouch -XX:+HeapDumpOnOutOfMemoryError -XX:+UseG1GC -XX:G1HeapRegionSize&#x3D;4M -XX:InitiatingHeapOccupancyPercent&#x3D;40 -XX:MaxGCPauseMillis&#x3D;100 -XX:+TieredCompilation -XX:CICompilerCount&#x3D;4 -XX:-UseBiasedLocking -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintStringTableStatistics -XX:+PrintAdaptiveSizePolicy -XX:+PrintGCApplicationStoppedTime -XX:+PrintFlagsFinal -XX:-UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;10 -XX:GCLogFileSize&#x3D;10M -Xloggc:&#x2F;var&#x2F;gc.log.20230208 -XX:ErrorFile&#x3D;&#x2F;vmerr.log.20230208 -XX:HeapDumpPath&#x3D;&#x2F;var&#x2F;heaperr.log.20230208 -Xbootclasspath&#x2F;a:BOOT-INF&#x2F;lib&#x2F;hexo 1.2.3.jar -javaagent:BOOT-INF&#x2F;lib&#x2F;agent-1.2.3.jar -Dspring.profiles.active&#x3D;prod -jar .&#x2F;2.0.0-SNAPSHOT.jar</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/02/27/2023-02-27-redis-goosip%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/27/2023-02-27-redis-goosip%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">2023-02-27-redis-goosip协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-27 10:10:49 / Modified: 10:13:35" itemprop="dateCreated datePublished" datetime="2023-02-27T10:10:49+08:00">2023-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="goosip-协议"><a href="#goosip-协议" class="headerlink" title="goosip 协议"></a>goosip 协议</h1><blockquote>
<p>关键词： 分布式、弱一致性算法</p>
</blockquote>
<p>goosip 英文释义：流言蜚语。早先论文所表达的意思是[流行病算法]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/02/22/2023-02-22-rocketmq-nameserver%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/2023-02-22-rocketmq-nameserver%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">2023-02-22-rocketmq-nameserver数据一致性分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-22 15:20:57" itemprop="dateCreated datePublished" datetime="2023-02-22T15:20:57+08:00">2023-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-23 09:49:02" itemprop="dateModified" datetime="2023-02-23T09:49:02+08:00">2023-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NameServer保障数据一致性分析"><a href="#NameServer保障数据一致性分析" class="headerlink" title="NameServer保障数据一致性分析"></a>NameServer保障数据一致性分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NameServer：名称服务，充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，无状态，没有信息交换。</p>
<p>NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo或者kafka中的zookeeper，Spring Cloud 中的 Eureka，NameServer支持Broker的动态注册与发现。主要包括两个功能：</p>
<p>Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活。<br>路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。Producer在投递消息之前和Conumser在拉取消息之前，都会通过NameServer获取整个Broker集群的路由信息，从而进行消息的投递和消费。</p>
<h2 id="设计考量"><a href="#设计考量" class="headerlink" title="设计考量"></a>设计考量</h2><p>作为命名服务，有些组件会选用zk作为一致性存储的中间件，保障数据的强一致性。<br>但NameServer保障数据的最终一致性，以提升系统可用性，因此，RocketMQ自制的NameServer实现的是AP。</p>
<p>由此，RocketMQ的架构设计决定了只需要一个轻量级的元数据服务器就足够了，只需要保持最终一致，因此，RocketMQ决定使用自制的NameServer来实现简单的路由管理服务，将元数据存储在RocketMQ内部，设计很简单，非常的轻量级。NameServer 集群间互不通信，因此它们之间的注册信息可能会不一致，这是一种去中心化的架构，所有注册信息保存在内存中（无状态），一台NameServer挂了也没关系，从另一台NameServer上拉取数据即可。</p>
<h2 id="如何做到nameserver不去做信息交换？"><a href="#如何做到nameserver不去做信息交换？" class="headerlink" title="如何做到nameserver不去做信息交换？"></a>如何做到nameserver不去做信息交换？</h2><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。<br>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。<br>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。<br>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。<br>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/02/15/2023-02-15-MYSQL-MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/15/2023-02-15-MYSQL-MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">2023-02-15-MYSQL-MVCC的实现机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-15 16:15:54 / Modified: 17:14:46" itemprop="dateCreated datePublished" datetime="2023-02-15T16:15:54+08:00">2023-02-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存</p>
<blockquote>
<p>我的一句话概括：提升数据库并发读的能力，不加锁的并发读<br>实现路径是通过undo log，记录当前事务的历史修改版本，并基于事务id顺序，实现snapshot读取<br>innodb 的可重复读是基于MVCC实现的</p>
</blockquote>
<h2 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h2><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本，比如用于可重复读的场景</p>
<h3 id="RC和RR-使用MVCC有啥不同"><a href="#RC和RR-使用MVCC有啥不同" class="headerlink" title="RC和RR 使用MVCC有啥不同"></a>RC和RR 使用MVCC有啥不同</h3><p>原因：对于 RR 、RC级别来说，其实整个过程几乎一样，唯一不同的是生成 ReadView 的时机，RR 级别只在事务开始时生成一次，之后一直使用该 ReadView。而 RC 级别则在每次 select 时，都会生成一个 ReadView。</p>
<p>所以RR永远保持同一个readview</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/02/15/2023-02-15-MYSQL-MGR-%E5%8A%9F%E8%83%BD%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/15/2023-02-15-MYSQL-MGR-%E5%8A%9F%E8%83%BD%E5%88%86%E4%BA%AB/" class="post-title-link" itemprop="url">2023-02-15-MYSQL-MGR-功能分享</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-15 15:10:58 / Modified: 15:24:30" itemprop="dateCreated datePublished" datetime="2023-02-15T15:10:58+08:00">2023-02-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>不会有脑裂，保障数据不一致</li>
<li>HA</li>
</ol>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol>
<li>大字段、大事务不友好(&lt;16mb)，主从同理存在一样的问题</li>
<li>相比主从，现阶段不建议用大流量，某些情况可能会导致不一致，导致节点被踢</li>
<li>4000 qps 算大流量，再大的流量可能会有性能抖动</li>
<li>一致性协议对网络影响非常敏感，异地部署存在问题</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/02/01/2023-02-01-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AF%BC%E5%9B%BE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/2023-02-01-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AF%BC%E5%9B%BE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2023-02-01-高性能导图总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-01 11:00:07 / Modified: 11:03:51" itemprop="dateCreated datePublished" datetime="2023-02-01T11:00:07+08:00">2023-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高性能之道"><a href="#高性能之道" class="headerlink" title="高性能之道"></a>高性能之道</h1><ul>
<li>无锁<ul>
<li>串行无锁</li>
<li>结构无锁</li>
</ul>
</li>
<li>零拷贝<ul>
<li>内存映射</li>
<li>零拷贝</li>
</ul>
</li>
<li>序列化<ul>
<li>分类</li>
<li>性能指标</li>
<li>选型</li>
</ul>
</li>
<li>池化技术<ul>
<li>内存池</li>
<li>线程池</li>
<li>连接池</li>
<li>对象池</li>
</ul>
</li>
<li>并发化<ul>
<li>请求并发</li>
</ul>
</li>
<li>缓存<ul>
<li>分类</li>
<li>回收策略</li>
<li>使用模式</li>
<li>崩溃恢复</li>
</ul>
</li>
<li>分片<ul>
<li>分片策略</li>
<li>二级索引</li>
<li>路由策略</li>
<li>动态平衡</li>
<li>分库分表</li>
<li>任务分片</li>
</ul>
</li>
<li>队列<ul>
<li>异步处理</li>
<li>削峰填谷</li>
<li>结构</li>
<li>数据同步</li>
<li>柔性事务</li>
</ul>
</li>
<li>存储<ul>
<li>读写分离</li>
<li>冷热分离</li>
<li>动静分离</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2023/01/31/2023-01-31-ring-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/2023-01-31-ring-buffer/" class="post-title-link" itemprop="url">2023-01-31-ring-buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-31 20:11:10 / Modified: 20:27:13" itemprop="dateCreated datePublished" datetime="2023-01-31T20:11:10+08:00">2023-01-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Ring-Buffer"><a href="#Ring-Buffer" class="headerlink" title="Ring Buffer"></a>Ring Buffer</h1><h2 id="环境队列"><a href="#环境队列" class="headerlink" title="环境队列"></a>环境队列</h2><p>环形队列，Circular Queue，或者也被称为 Ring Buffer，Circular Buffer，Cyclic Buffer 等等，是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。它的学术上的研讨不在本文的展开范围内，简而言之，不但是通信开发（Socket，TCP&#x2F;IP，RPC开发）中，在内核的IPC中，在视频音频播放中，在类似于 Map-Reduce 的工作队列排列中，在广泛的各种需要<strong>数据流</strong>数据结构表示的场景中，环形队列往往是一种最佳选择。</p>
<p>比如网卡的处理缓存区</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>计算机内存是线性而非是环状的，因而当环形队列被实现到内存中时，通常会用一个连续的内存块来表示，同时通过使用一对额外的指针来指示首、尾位置，从而在逻辑上将其卷曲起来</p>
<p>首先，环形队列是有界的。环形队列适合于事先明确了缓冲区的最大容量的情形。扩展一个环形队列的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。</p>
<p>其次，环形队列是一种 FIFO 数据结构。它和普通 FIFO 队列数据结构的不同就在于队尾连接着队首，当入列元素位于队尾时，该元素将被回绕并放在队首的位置，从而完成有界性限定。而普通的 FIFO 队列总是增长队尾以入列新元素，并不限制队列的有效长度。</p>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>因为是FIFO的结构，所以有一个特性是：当一个数据元素被用掉后，其余数据元素不需要移动其存储位置。</p>
<p>相反，一个非环形队列（例如一个普通的队列）在用掉一个数据元素后，其余数据元素需要向前搬移（这也并非必须如此，链表可以避免数据搬移带来的读写性能差，但也会进一步衍生出新的问题——其链表指针操作难以无锁化导致SMP场景中读写性能差）。</p>
<p>正是因为这一特性，环形队列具有先天优势，无需数据搬移（也避免了动态内存分配）。而由于环形队列通常仅仅需要固定的首尾两个指针（一般的实现中，这两个指针实际上都是数组的下标值）即可访问，因而很容易解决 SMP 场景中的无锁化问题</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>一般的，圆形缓冲区需要4个指针：</p>
<ol>
<li>在内存中实际开始位置；</li>
<li>在内存中实际结束位置，也可以用缓冲区长度代替；</li>
<li>存储在缓冲区中的有效数据的开始位置（读指针）；</li>
<li>存储在缓冲区中的有效数据的结尾位置（写指针）。<br>读指针、写指针可以用整型值来表示。</li>
</ol>
<h2 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<p>环形数组结构<br>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
<p>元素位置定位<br>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
<p>无锁设计<br>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
<p>一般情况下队列可以使用JDK提供的阻塞队列，在高性能场景下 disruptor 使用精巧的设计，通过无锁（CAS）提升了并发。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/11/07/2022-11-07-k8s%E7%9A%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/2022-11-07-k8s%E7%9A%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">2022-11-07-k8s的概念整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-07 21:31:11" itemprop="dateCreated datePublished" datetime="2022-11-07T21:31:11+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-14 20:41:13" itemprop="dateModified" datetime="2022-11-14T20:41:13+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>⾸先，最重要的是你需要认识到 利⽤了“期望状态 ”原则。定义了组件的期望状态，k8S将之调整到期望状态。</p>
<p>例如，你想让你的 Web 服务器始终运⾏在 4 个容器中，以达到负载均衡的⽬的， 你的数据库复制到 3 个不同的容器中，以达到冗余的⽬的。这就是你想要的状态。 如果这 7 个容器中的任何⼀个出现故障，Kubernetes 引擎会检测到这个问题，并自动创建一个新的容器，以确保维持所需的状态</p>
<h2 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h2><p>API对象是K8S的管理操作单元，每个API对象有三个属性，元数据metadata，规范spec，状态status。<br>每个对象至少有三个元数据namespace，name，uid，还可以有各种各样的标签label</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/06/30/2022-06-30-%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E4%B9%8BDH-ECDH-ECDHE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/2022-06-30-%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E4%B9%8BDH-ECDH-ECDHE/" class="post-title-link" itemprop="url">密钥协商之DH,ECDH,ECDHE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-30 19:54:43" itemprop="dateCreated datePublished" datetime="2022-06-30T19:54:43+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-01 14:50:33" itemprop="dateModified" datetime="2022-07-01T14:50:33+08:00">2022-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是DH？"><a href="#什么是DH？" class="headerlink" title="什么是DH？"></a>什么是DH？</h1><p>Diffie-Hellman密钥交换算法是在1976年由这两个人发明的算法。它可以在不安全的网络中，通过交换一些公开的信息协商出共享密钥，使用此共享密钥建立安全通讯。它实际上并没有直接交换密钥，而是通过数学计算，得出共享密钥。</p>
<h1 id="在DH算法之前-RSA密钥交换算法"><a href="#在DH算法之前-RSA密钥交换算法" class="headerlink" title="在DH算法之前 - RSA密钥交换算法"></a>在DH算法之前 - RSA密钥交换算法</h1><p>我们构建这么一种场景，服务器配置有公钥+私钥，客户端是离散的。</p>
<pre><code>RSA算法流程文字描述如下：

（1）：任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。

（2）：客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行 加密，生成C，把C发送到服务器。

（3）：服务器收到C，使用公钥对应的私钥进行解密，得到S。

（4）：上述交换步骤后，客户端和服务器都得到了S，S为密钥（预主密钥）。
</code></pre>
<h2 id="RSA算法的问题"><a href="#RSA算法的问题" class="headerlink" title="RSA算法的问题"></a>RSA算法的问题</h2><h3 id="前向安全问题"><a href="#前向安全问题" class="headerlink" title="前向安全问题"></a>前向安全问题</h3><p>就是如果私钥泄漏，即私钥被第三方知道，那么第三方就能从C中解密得到S，即只要保存所有的A和B的报文，等到私钥被泄漏的那一天，或者有办法快从C中计算S的方法出现（量子计算机分解大素数），那么A和B就没有什么私密性可言了。</p>
<p>这就是所谓的前向不安全，私钥参与了密钥交换，安全性取决于私钥是否安全保存。</p>
<h1 id="一句话说DH"><a href="#一句话说DH" class="headerlink" title="一句话说DH"></a>一句话说DH</h1><p>利用临时生成（固定的）的一堆公私钥，完成master key的交换</p>
<h1 id="DHE是什么？-Ephemeral"><a href="#DHE是什么？-Ephemeral" class="headerlink" title="DHE是什么？ - Ephemeral"></a>DHE是什么？ - Ephemeral</h1><ul>
<li><p>静态DH：通信双方有一方的私有密钥是固定的，另一方临时生成，一般是服务器端固定。但是这样随着时间的验证，很容易被破解，而一旦被破解，之前所有的通讯数据都很容易被解密，不具备前向安全的特性。目前静态DH基本不同。</p>
</li>
<li><p>既然静态DH算法中，一方固定一方临时生成的方式不安全，那么我们就双方都不固定。通讯双方的私有密钥都采用临时生成的方式，这中DH算法称之为DHE算法（E是指Ephemeral, 临时的）。</p>
</li>
</ul>
<blockquote>
<p>用一句话说，唯一的区别就是DHE是由随机值生成密钥</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/05/06/2022-05-06-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/06/2022-05-06-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">G1垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-06 14:52:39" itemprop="dateCreated datePublished" datetime="2022-05-06T14:52:39+08:00">2022-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-01 14:50:48" itemprop="dateModified" datetime="2022-07-01T14:50:48+08:00">2022-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h1><p>在JDK8中，有多种垃圾回收算法，比如Prallel GC，CMS，G1</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>G1收集器是同时包含了年轻代，和老年代收集的，是ZGC更新前的垃圾回收算法</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</p>
<ul>
<li>服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</li>
<li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li>
<li>想要更可控、可预期的GC停顿周期，防止高并发下应用雪崩现象</li>
</ul>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="/2022/05/06/2022-05-06-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png" alt="图 1">  </p>
<p>G1将堆内存切分成很多个固定大小的区域，每个是连续范围的虚拟内存。<br>堆内存中一个区域的大小可以通过 -XX:G1HeapRegionSize参数指定（最小1M,最大32M）</p>
<p>默认情况下堆内存均分成2048份</p>
<h2 id="分代方法"><a href="#分代方法" class="headerlink" title="分代方法"></a>分代方法</h2><p>对于每个region，通过不同标记从逻辑上映射成Eden，Survivor和老年代。</p>
<p>除了这几种分代外，还有第四种类型，被称为巨型区域，Humongous Regions,用于存储超过50%标准region大小的喜爱那个设计的。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p>
<h2 id="回收阶段（global-concurrent-marking）"><a href="#回收阶段（global-concurrent-marking）" class="headerlink" title="回收阶段（global concurrent marking）"></a>回收阶段（global concurrent marking）</h2><ol>
<li><p>初始标记 inital Marking</p>
<p> 这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。</p>
<p> tips: 哪些对象是GC Root（static 变量，栈上的变量（类型参数，局部变量，临时值），JNI），GC的过程是找出活的对象，并把其余空间认定为“无用”，而不是找出所有死掉的对象</p>
</li>
<li><p>G1执行的第二阶段：并发标记</p>
<p> 从1阶段搜索出来的GC ROOTS开始对对象进行可达性分分析，找出存活对象</p>
</li>
<li><p>最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）</p>
</li>
<li><p>筛选回收（首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region）</p>
<p> 最后，G1中提供了两种模式垃圾回收模式，Young GC和Mixed GC，两种存在Stop The World(STW)的阶段。</p>
</li>
</ol>
<h3 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h3><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p>当Eden region使用达到最大阈值并且无法申请最够内存时，会触发young GC，每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。</p>
<p>YoungGC的回收过程如下：</p>
<ul>
<li>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</li>
<li>处理Dirty card,更新RSet.</li>
<li>扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</li>
<li>拷贝扫描出的存活的对象到survivor2&#x2F;old区</li>
<li>处理引用队列，软引用，弱引用，虚引用</li>
</ul>
<h4 id="mixed-gc"><a href="#mixed-gc" class="headerlink" title="mixed gc"></a>mixed gc</h4><p>当越来越多的对象晋升到olg region后，虚拟机会触发mixed gc，回收整个young region和一部分old region。这里需要注意，是<strong>一部分</strong>老年，也不是全部老年代，从而可以对垃圾回收的耗时进行控制</p>
<p>G1没有full GC的概念，需要full GC时，调用 serial Old gc 进行全堆扫描。所以Mixed GC不是Full GC，它只能回收部分老年代的Region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC(Full GC)来收集整个GC heap。 所以本质上，G1是不提供Full GC的。</p>
<h1 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h1><p>如果应用程序使用CMS或ParallelOld垃圾回收器具有一个或多个以下特征，将有利于切换到G1：</p>
<ul>
<li>Full GC持续时间太长或太频繁</li>
<li>对象分配率或年轻代升级老年代很频繁</li>
<li>不期望的很长的垃圾收集时间或压缩暂停（超过0.5至1秒）</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="停顿-STW-预测模型"><a href="#停顿-STW-预测模型" class="headerlink" title="停顿(STW)预测模型"></a>停顿(STW)预测模型</h2><p>G1收集器突出表现出来的一点是通过一个停顿预测模型根据用户配置的停顿时间来选择CSet的大小，从而达到用户期待的应用程序暂停时间。通过 -XX:MaxGCPauseMillis 参数来设置。这一点有点类似于ParallelScavenge收集器。关于停顿时间的设置并不是越短越好。</p>
<p>设置的时间越短意味着每次收集的CSet越小，导致垃圾逐步积累变多，最终不得不退化成Serial GC。<br>停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间</p>
<blockquote>
<p>当Mixed GC赶不上对象产生的速度的时候就退化成Full GC,这一点是需要重点调优的地。</p>
</blockquote>
<h2 id="不需要手工设置新生代和老年代的大小"><a href="#不需要手工设置新生代和老年代的大小" class="headerlink" title="不需要手工设置新生代和老年代的大小"></a>不需要手工设置新生代和老年代的大小</h2><p>G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。<br>设置了新生代大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的小即可。</p>
<h1 id="原理-–-todo"><a href="#原理-–-todo" class="headerlink" title="原理 – todo"></a>原理 – todo</h1><h2 id="Rset和卡表"><a href="#Rset和卡表" class="headerlink" title="Rset和卡表"></a>Rset和卡表</h2><h2 id="三色标记算法和SATB"><a href="#三色标记算法和SATB" class="headerlink" title="三色标记算法和SATB"></a>三色标记算法和SATB</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/30/2022-03-30-druid-getConnection%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-removeAbandoned%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/30/2022-03-30-druid-getConnection%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-removeAbandoned%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">Druid-getConnection性能优化-removeAbandoned功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-30 11:54:37" itemprop="dateCreated datePublished" datetime="2022-03-30T11:54:37+08:00">2022-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-01 14:50:48" itemprop="dateModified" datetime="2022-07-01T14:50:48+08:00">2022-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p><img src="/2022/03/30/2022-03-30-druid-getConnection%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-removeAbandoned%E5%8A%9F%E8%83%BD/2022-03-30-12-03-16.png"></p>
<p>在生成服务火焰图的时候，发现了服务在getConnection的时候出现了平台，其中会瓶颈点在Thread.getStackTrace()</p>
<blockquote>
<p>Druid 版本 1.0.12</p>
</blockquote>
<h1 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h1><p>可以看到如果，isRemoveAbandoned()为true时，会调用getStackTrace()获取当前线程信息，记录在类中，这个是一个比较慢的操作，也是慢的原因</p>
<pre><code class="java">    public DruidPooledConnection getConnectionDirect(long maxWaitMillis) throws SQLException &#123;
        int notFullTimeoutRetryCnt = 0;
        for (;;) &#123;
            // handle notFullTimeoutRetry
            DruidPooledConnection poolableConnection;
            try &#123;
                poolableConnection = getConnectionInternal(maxWaitMillis);
            &#125; catch (GetConnectionTimeoutException ex) &#123;
                if (notFullTimeoutRetryCnt &lt;= this.notFullTimeoutRetryCount &amp;&amp; !isFull()) &#123;
                    notFullTimeoutRetryCnt++;
                    if (LOG.isWarnEnabled()) &#123;
                        LOG.warn(&quot;not full timeout retry : &quot; + notFullTimeoutRetryCnt);
                    &#125;
                    continue;
                &#125;
                throw ex;
            &#125;

            if (isTestOnBorrow()) &#123;
                boolean validate = testConnectionInternal(poolableConnection.getConnection());
                if (!validate) &#123;
                    if (LOG.isDebugEnabled()) &#123;
                        LOG.debug(&quot;skip not validate connection.&quot;);
                    &#125;

                    Connection realConnection = poolableConnection.getConnection();
                    discardConnection(realConnection);
                    continue;
                &#125;
            &#125; else &#123;
                Connection realConnection = poolableConnection.getConnection();
                if (realConnection.isClosed()) &#123;
                    discardConnection(null); // 传入null，避免重复关闭
                    continue;
                &#125;

                if (isTestWhileIdle()) &#123;
                    final long currentTimeMillis = System.currentTimeMillis();
                    final long lastActiveTimeMillis = poolableConnection.getConnectionHolder().getLastActiveTimeMillis();
                    final long idleMillis = currentTimeMillis - lastActiveTimeMillis;
                    long timeBetweenEvictionRunsMillis = this.getTimeBetweenEvictionRunsMillis();
                    if (timeBetweenEvictionRunsMillis &lt;= 0) &#123;
                        timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
                    &#125;

                    if (idleMillis &gt;= timeBetweenEvictionRunsMillis) &#123;
                        boolean validate = testConnectionInternal(poolableConnection.getConnection());
                        if (!validate) &#123;
                            if (LOG.isDebugEnabled()) &#123;
                                LOG.debug(&quot;skip not validate connection.&quot;);
                            &#125;

                            discardConnection(realConnection);
                            continue;
                        &#125;
                    &#125;
                &#125;
            &#125;

            if (isRemoveAbandoned()) &#123;
                StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
                poolableConnection.setConnectStackTrace(stackTrace);
                poolableConnection.setConnectedTimeNano();
                poolableConnection.setTraceEnable(true);

                synchronized (activeConnections) &#123;
                    activeConnections.put(poolableConnection, PRESENT);
                &#125;
            &#125;

            if (!this.isDefaultAutoCommit()) &#123;
                poolableConnection.setAutoCommit(false);
            &#125;

            return poolableConnection;
        &#125;
    &#125;
</code></pre>
<h1 id="removeAbandoned-功能"><a href="#removeAbandoned-功能" class="headerlink" title="removeAbandoned 功能"></a>removeAbandoned 功能</h1><p>这个功能是干什么的呢？<br>实际上是Druid用于定时检测是不是有申请但是没有归还的链接的，如果一个链接拿走了，但是超过时间没有归还，那就这个功能会自动回收。本质是为了防止连接泄漏的。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>这个功能在公司组件里是<strong>默认开启</strong>的，如果开启了这个功能，在每次获取链接的时候都会尝试获取当前线程栈，获取当前线程栈的调用是比较消耗性能的。</p>
<p>理论上目前大多数应用都是基于Mybatis或者Spring框架使用DataSource的，一般不会有裸用dataSource的情况，所以也用不上这个功能，徒增了消耗，所以当前功能也不是很有必要。想不通为啥会默认开启…</p>
<p>在官方的实现里是默认<strong>关闭</strong>，并且在issue中还有建议是在出现泄漏问题或者排查问题的时候在开启，所以如果没有必要的话，关闭掉这个功能就好了~~</p>
<blockquote>
<p>据说单个拿链接的时间可以缩短十分之一~</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/26/2022-03-26-%E7%BA%BF%E6%AE%B5%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/2022-03-26-%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="post-title-link" itemprop="url">线段树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-26 18:14:48" itemprop="dateCreated datePublished" datetime="2022-03-26T18:14:48+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-01 16:26:29" itemprop="dateModified" datetime="2022-04-01T16:26:29+08:00">2022-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>线段树 - segement tree</p>
</blockquote>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>存放给定区间内对应信息的一种数据结构。与树状数组类似（binary tree），可以用来处理数组的区间查询(range query)和元素更新。与树状数组不同的是，线段树还可以用于区间求和的查询，也可以进行区间最大值、最小值、异或的查询。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>完全二叉树存储每一个区间的数据</li>
<li>没一个节点保存着对应这个区间的信息</li>
<li>使用一个数组来保存</li>
</ul>
<blockquote>
<p> 例如，给定一个长度为N的数组arr，其所对应的线段树T各个结点的含义如下：</p>
<ol>
<li>T的根结点代表整个数组所在的区间对应的信息，及arr[0:N]（不含N)所对应的信息。</li>
<li>T的每一个叶结点存储对应于输入数组的每一个单个元素构成的区间arr[i]所对应的信息，此处0≤i&lt;N。</li>
<li>T的每一个中间结点存储对应于输入数组某一区间arr[i:j]对应的信息，此处0≤i&lt;j&lt;N。</li>
</ol>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。</p>
<h1 id="常用用途"><a href="#常用用途" class="headerlink" title="常用用途"></a>常用用途</h1><ul>
<li>更新序列中的某一个元素</li>
<li>查询序列某个区间的最值，区间和，解决区间的统计问题</li>
<li>更新序列某个区内的所有值</li>
</ul>
<h1 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h1><p>以序列{5,9,7,4,6,1}为例子演示，这个序列构成的线段树是这样的。</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><pre><code class="java">public class SegmentTree &#123;
    //线段树
    Node[] segTree;
    //原始数据集
    int[] data;
&#125;
</code></pre>
<h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><pre><code class="java">class Node &#123;
    //左端点
    int start;
    //右端点
    int end;
    //数据值 可以是最大值 最小值 求和
    int data;
    //延迟更新的标记，用于区间更新提升性能
    int mark = 0;

    public Node(int start, int end) &#123;
        this.start = start;
        this.end = end;
    &#125;

    void setData(int data) &#123;
        this.data = data;
    &#125;

    void addMark(int value) &#123;
        this.mark += value;
    &#125;

    void clearMark() &#123;
        this.mark = 0;
    &#125;

    public String toString() &#123;
        return start + &quot;-&quot; + end;
    &#125;

&#125;
</code></pre>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="java">    public void build(int[] arr) &#123;
        //最坏情况需要4N个节点
        this.segTree = new Node[arr.length * 4];

    &#125;

    //递归建树
    private void build(int arr[], int start, int end) &#123;
        if (start &gt;= end) &#123;
            return;
        &#125;
        Node node = new Node(start, end);
        
    &#125;
</code></pre>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><h3 id="单点更新-1"><a href="#单点更新-1" class="headerlink" title="单点更新"></a>单点更新</h3><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="java">//todo
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/25/2022-03-25-%E5%A4%A9%E6%89%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%A5%9E%E8%AF%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/25/2022-03-25-%E5%A4%A9%E6%89%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%A5%9E%E8%AF%9D/" class="post-title-link" itemprop="url">天才程序员的神话</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-25 11:12:39 / Modified: 11:46:40" itemprop="dateCreated datePublished" datetime="2022-03-25T11:12:39+08:00">2022-03-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-Myth-of-the-Genius-Programmer"><a href="#The-Myth-of-the-Genius-Programmer" class="headerlink" title="The Myth of the Genius Programmer"></a>The Myth of the Genius Programmer</h1><blockquote>
<p>各种摘抄</p>
</blockquote>
<pre><code>谦虚
      你并不是宇宙的中心，你做不到无所不知从不犯错，你需要不断完善自己。
尊重
      你要关心一起工作的人，做到平等待人，尊重他们的能力和他们的工作。
信任
      你要相信同伴的能力，相信他们可以把事情做好，在适当的时候放手让他们去做。
</code></pre>
<pre><code>所有这些关于谦虚、尊重、信任的说教，听起来像是一些让人云里雾里的大道理。让我们从这其中走出来，想一想在现实生活中要如何应用这些观点。为了寻找到一些实际中的情况，我们将检视一些你会遇到的具体的言谈举止和例子。其中很多起初听起来会很平常，但如果你仔细想一想，你会发现或许你犯了错误，并没有按照HRT的要求行事。

不要太自我,OK，这里有些简单的方式来告诫那些不够谦逊的人来放低姿态。没人愿意和自以为是的人一起工作。即使你知道你是最聪明的，也不要在别人面前指手画脚。想一想，你是不是觉得自己应该在每个讨论的话题上第一个发言，或者都要做总结发言？你是不是觉得有必要在讨论的每一个细节上都发表意见？或者，你知道有谁会像上面说的这样吗？

这里所说的谦逊并不是要做垫底的，保持自信是没有错误的。只是不要什么时候都像个百事通。更胜一筹的方式是用集体替代自我，与其担心自己是否真的了不起，不如尝试建立团队成就感。阿帕奇软件基金会在围绕软件项目组建社区上已经有很长的历史了，这些社区有令人难以置信地的特性，它们拒绝那些更在乎推销自己的人。
</code></pre>
<pre><code>举个例子来说，如果你预计自己的接下来的要做的事情可能会让同伴们不安，那你就不要直接说“你这个方法的流程完全错了。你应该像别人一样使用标准xyzzy代码模式”。当你告诉一个人他犯了个错误（其实也没有绝对正确的事情），批评他做的和别人都不一样（这会让他觉得自己是个傻瓜）的时候，你当然希望他能按你的要求进行修改。但是，事情可能并不会想你预期的这样发展，结果很可能是换来对方激烈的反应。

同样一件事情，更好的处理方式或许是这样的，“嗨，我对这里的流程不太明白，我想如果使用xyzzy代码模式可能会更清楚一点，将来维护起来也能更简单吧”。注意，这里是你在谦逊的问他，而不是他来问你。记住，他并没有错误，只是你对这段代码理解起来有困难。你的建议仅仅是希望可以让自己更好的明白这段代码，或许后面的维护也会更简单。同样的，你也不要要求他做任何事情，你要允许对方不采纳你的建议。你要把这个问题仅限制在这段代码中，不要牵涉任何个人能力的问题。
</code></pre>
<pre><code>我们在Google工作时，最喜欢的一条Google格言是“失败是一个可选项”。目前广泛认可的观点是，如果你从来没有失败过，说明你没有足够的创造力，或者没有勇气来进行冒险。我们应该把失败视作学习和提高黄金机会。事实上，爱迪生经常说“如果我发现10,000种方法都不行，我并不认为这是失败。我不会气馁，因为每一次失败的尝试都是向前迈进了一步”。
</code></pre>
<pre><code>不是这样的。承认自己犯错误，承认自己有些掉队，这在长远来看是帮助自己提高的一种方式。事实上，这包含了所有HRT的要素，它需要我们表现出谦逊的态度，需要我们了解关于职责和承担的意义，同时也表明你信任别人的意见，而作为回报，人们将会尊重你的诚实和能力。所以有时候，你最应该做的事情就是说出“我不知道”。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/22/2022-03-22-intel-sgx-%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/2022-03-22-intel-sgx-%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">intel-sgx-开发指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 20:42:45" itemprop="dateCreated datePublished" datetime="2022-03-22T20:42:45+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-23 15:25:22" itemprop="dateModified" datetime="2022-03-23T15:25:22+08:00">2022-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="占个坑慢慢补"><a href="#占个坑慢慢补" class="headerlink" title="占个坑慢慢补"></a>占个坑慢慢补</h1><p><img src="/cd2b020cc8b09d3aeaf8c6404233d1aee0bf8fd10cd29731ba70b5f8df6c4255.png" alt="图 1">  </p>
<p><img src="/2022-03-23-15-25-13.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/22/2022-03-22-Netty-ChannelFuture-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/2022-03-22-Netty-ChannelFuture-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Netty-ChannelFuture-源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 20:03:27" itemprop="dateCreated datePublished" datetime="2022-03-22T20:03:27+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-24 14:21:39" itemprop="dateModified" datetime="2022-03-24T14:21:39+08:00">2022-03-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>源码版本为: netty-all-4.1.59.Final</p>
</blockquote>
<h1 id="异步和事件驱动"><a href="#异步和事件驱动" class="headerlink" title="异步和事件驱动"></a>异步和事件驱动</h1><p>Netty 是异步事件驱动的框架，该框架体现为所有的I&#x2F;O操作都是异步的，所有的I&#x2F;O调用会立即返回，并不保证调用成功与否，但是调用会返回ChannelFuture。Netty 会通过 ChannelFuture通知调用是成功了还是失败了，抑或是取消了。</p>
<h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p>这里是其中一个顶层类的接口实现，可以看到除了future的isDone以外，还增加了isSuccess，cause等接口</p>
<pre><code class="java">
                                        +---------------------------+
                                        | Completed successfully    |
                                        +---------------------------+
                                   +----&gt;      isDone() = true      |
   +--------------------------+    |    |   isSuccess() = true      |
   |        Uncompleted       |    |    +===========================+
   +--------------------------+    |    | Completed with failure    |
   |      isDone() = false    |    |    +---------------------------+
   |   isSuccess() = false    |----+----&gt;      isDone() = true      |
   | isCancelled() = false    |    |    |       cause() = non-null  |
   |       cause() = null     |    |    +===========================+
   +--------------------------+    |    | Completed by cancellation |
                                   |    +---------------------------+
                                   +----&gt;      isDone() = true      |
                                        | isCancelled() = true      |
                                        +---------------------------+

public interface Future&lt;V&gt; extends java.util.concurrent.Future&lt;V&gt; &#123;

    /**
     * Returns &#123;@code true&#125; if and only if the I/O operation was completed
     * successfully.
     */
    boolean isSuccess();

    /**
     * returns &#123;@code true&#125; if and only if the operation can be cancelled via &#123;@link #cancel(boolean)&#125;.
     */
    boolean isCancellable();

    /**
     * Returns the cause of the failed I/O operation if the I/O operation has
     * failed.
     *
     * @return the cause of the failure.
     *         &#123;@code null&#125; if succeeded or this future is not
     *         completed yet.
     */
    Throwable cause();

    /**
     * Adds the specified listener to this future.  The
     * specified listener is notified when this future is
     * &#123;@linkplain #isDone() done&#125;.  If this future is already
     * completed, the specified listener is notified immediately.
     */
    Future&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    /**
     * Adds the specified listeners to this future.  The
     * specified listeners are notified when this future is
     * &#123;@linkplain #isDone() done&#125;.  If this future is already
     * completed, the specified listeners are notified immediately.
     */
    Future&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    /**
     * Removes the first occurrence of the specified listener from this future.
     * The specified listener is no longer notified when this
     * future is &#123;@linkplain #isDone() done&#125;.  If the specified
     * listener is not associated with this future, this method
     * does nothing and returns silently.
     */
    Future&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    /**
     * Removes the first occurrence for each of the listeners from this future.
     * The specified listeners are no longer notified when this
     * future is &#123;@linkplain #isDone() done&#125;.  If the specified
     * listeners are not associated with this future, this method
     * does nothing and returns silently.
     */
    Future&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    /**
     * Waits for this future until it is done, and rethrows the cause of the failure if this future
     * failed.
     */
    Future&lt;V&gt; sync() throws InterruptedException;

    /**
     * Waits for this future until it is done, and rethrows the cause of the failure if this future
     * failed.
     */
    Future&lt;V&gt; syncUninterruptibly();

    /**
     * Waits for this future to be completed.
     *
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    Future&lt;V&gt; await() throws InterruptedException;

    /**
     * Waits for this future to be completed without
     * interruption.  This method catches an &#123;@link InterruptedException&#125; and
     * discards it silently.
     */
    Future&lt;V&gt; awaitUninterruptibly();

    /**
     * Waits for this future to be completed within the
     * specified time limit.
     *
     * @return &#123;@code true&#125; if and only if the future was completed within
     *         the specified time limit
     *
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    boolean await(long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * Waits for this future to be completed within the
     * specified time limit.
     *
     * @return &#123;@code true&#125; if and only if the future was completed within
     *         the specified time limit
     *
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    boolean await(long timeoutMillis) throws InterruptedException;

    /**
     * Waits for this future to be completed within the
     * specified time limit without interruption.  This method catches an
     * &#123;@link InterruptedException&#125; and discards it silently.
     *
     * @return &#123;@code true&#125; if and only if the future was completed within
     *         the specified time limit
     */
    boolean awaitUninterruptibly(long timeout, TimeUnit unit);

    /**
     * Waits for this future to be completed within the
     * specified time limit without interruption.  This method catches an
     * &#123;@link InterruptedException&#125; and discards it silently.
     *
     * @return &#123;@code true&#125; if and only if the future was completed within
     *         the specified time limit
     */
    boolean awaitUninterruptibly(long timeoutMillis);

    /**
     * Return the result without blocking. If the future is not done yet this will return &#123;@code null&#125;.
     *
     * As it is possible that a &#123;@code null&#125; value is used to mark the future as successful you also need to check
     * if the future is really done with &#123;@link #isDone()&#125; and not relay on the returned &#123;@code null&#125; value.
     */
    V getNow();

    /**
     * &#123;@inheritDoc&#125;
     *
     * If the cancellation was successful it will fail the future with an &#123;@link CancellationException&#125;.
     */
    @Override
    boolean cancel(boolean mayInterruptIfRunning);
&#125;



public interface ChannelFuture extends Future&lt;Void&gt; &#123;

    /**
     * Returns a channel where the I/O operation associated with this
     * future takes place.
     */
    Channel channel();

    @Override
    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelFuture sync() throws InterruptedException;

    @Override
    ChannelFuture syncUninterruptibly();

    @Override
    ChannelFuture await() throws InterruptedException;

    @Override
    ChannelFuture awaitUninterruptibly();

    /**
     * Returns &#123;@code true&#125; if this &#123;@link ChannelFuture&#125; is a void future and so not allow to call any of the
     * following methods:
     * &lt;ul&gt;
     *     &lt;li&gt;&#123;@link #addListener(GenericFutureListener)&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #addListeners(GenericFutureListener[])&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #await()&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #await(long, TimeUnit)&#125; ()&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #await(long)&#125; ()&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #awaitUninterruptibly()&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #sync()&#125;&lt;/li&gt;
     *     &lt;li&gt;&#123;@link #syncUninterruptibly()&#125;&lt;/li&gt;
     * &lt;/ul&gt;
     */
    boolean isVoid();
    
</code></pre>
<p>ChannelFuture类似Java并发包的future类，不过功能有很多增强，比如对成功，失败的类型有区分，还有监听器的回调功能</p>
<p>刚创建的时候是uncomplete状态。当异步任务执行完后，会修改该类的状态。判断的方法有</p>
<ul>
<li>通过isDone方法来判断当前操作是否完成。</li>
<li>通过isSuccess方法来判断已完成的当前操作是否成功。</li>
<li>通过getCause方法来获取已完成的当前操作失败的原因。</li>
<li>通过isCancelled方法来判断已完成的当前操作是否被取消。</li>
</ul>
<h2 id="DefaultPromise"><a href="#DefaultPromise" class="headerlink" title="DefaultPromise"></a>DefaultPromise</h2><p>DefaultPromise是ChannelFuture的实现，这个是一个默认的实现方法</p>
<p>通过以下几个方法可以看到各个功能的实现方法</p>
<pre><code class="java">    
    public Promise&lt;V&gt; setSuccess(V result) &#123;
        //CAS更新RESULT_UPDATER的状态,
        if (setSuccess0(result)) &#123;
            //通知监听器
            notifyListeners();
            return this;
        &#125;
        throw new IllegalStateException(&quot;complete already: &quot; + this);
    &#125;


    private boolean setValue0(Object objResult) &#123;
        if (RESULT_UPDATER.compareAndSet(this, null, objResult) ||
            RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) &#123;
            checkNotifyWaiters();
            return true;
        &#125;
        return false;
    &#125;

    //如果有waiter的话唤醒waiter
    private synchronized void checkNotifyWaiters() &#123;
        if (waiters &gt; 0) &#123;
            notifyAll();
        &#125;
    &#125;


    private void notifyListeners() &#123;
        EventExecutor executor = executor();
        //判断当前线程和future所执行的，是不是同一个线程，是就直接执行
        if (executor.inEventLoop()) &#123;
            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
            final int stackDepth = threadLocals.futureListenerStackDepth();
            if (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;
                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
                try &#123;
                    notifyListenersNow();
                &#125; finally &#123;
                    threadLocals.setFutureListenerStackDepth(stackDepth);
                &#125;
                return;
            &#125;
        &#125;
        //不是的话，把当前这个任务丢给他所属的executor来执行
        safeExecute(executor, new Runnable() &#123;
            @Override
            public void run() &#123;
                notifyListenersNow();
            &#125;
        &#125;);
    &#125;

    //添加监听器的方法
    //Netty是异步的执行的，所以也兼容了添加监听器时当前任务可能是已经完成的情况，在添加监听器时，如果该任务已经完成了，那么也会调用notifyListeners的操作。所以可以放心使用监听器，即使异步任务已经完成了也可以挂载监听任务
    @Override
    public Promise&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener) &#123;
        checkNotNull(listener, &quot;listener&quot;);

        synchronized (this) &#123;
            addListener0(listener);
        &#125;

        if (isDone()) &#123;
            notifyListeners();
        &#125;

        return this;
    &#125;
</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="AbstractBootStrap-doBind"><a href="#AbstractBootStrap-doBind" class="headerlink" title="AbstractBootStrap.doBind()"></a>AbstractBootStrap.doBind()</h3><p>以Netty的启动过程为例子，看看future类是怎么用的</p>
<pre><code class="java">    
    private ChannelFuture doBind(final SocketAddress localAddress) &#123;
        //启动过程先拿到initAndRegister的Future
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) &#123;
            return regFuture;
        &#125;
        //如果这个时候已经注册完毕了，那就直接调用
        if (regFuture.isDone()) &#123;
            // At this point we know that the registration was complete and successful.
            // 创建一个新的promise promise和future的差别就是promise是可写可修改状态的
            ChannelPromise promise = channel.newPromise();
            //doBind的是一个异步操作，下面直接就返回了这个promise了
            //等doBind操作完后修改promise的状态
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        &#125; else &#123;
            // Registration future is almost always fulfilled already, but just in case it&#39;s not.
            //这里也好理解，因为之前判断注册任务没有完成，所以这里就挂载一个监听器，如果完成了的话就开始doBind的操作，从而实现整个过程都是异步的
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() &#123;
                @Override
                public void operationComplete(ChannelFuture future) throws Exception &#123;
                    Throwable cause = future.cause();
                    if (cause != null) &#123;
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    &#125; else &#123;
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();

                        doBind0(regFuture, channel, localAddress, promise);
                    &#125;
                &#125;
            &#125;);
            return promise;
        &#125;
    &#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="https://vildenh.github.io/2022/03/08/2022-03-08-openjdk-devel%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Vilden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vilden 's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/2022-03-08-openjdk-devel%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">openjdk-devel安装失败的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-08 21:47:59" itemprop="dateCreated datePublished" datetime="2022-03-08T21:47:59+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-17 11:01:25" itemprop="dateModified" datetime="2023-08-17T11:01:25+08:00">2023-08-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己的服务需要安装新版的openjdk去避免一些jdk的bug，结果发现了一很有意思的东西</p>
<p>正常的安装命令</p>
<blockquote>
<p> yum install java-1.8.0-openjdk-devel</p>
</blockquote>
<p>这样的安装方式会默认安装<strong>最新版</strong>的openjdk，在线上服务场景这样存在风险和隐患所以希望能够指定版本安装</p>
<p>所以想要使用的指定版本的方法安装，命令</p>
<blockquote>
<p> yum install java-1.8.0-openjdk-devel-1.8.0.312.b07-1.el7_9</p>
</blockquote>
<p>结果报了错</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Loaded plugins: fastestmirror, ovl, priorities<br>Determining fastest mirrors<br>Percona                                                                             | 2.9 kB  00:00:00     <br>base                                                                                | 3.6 kB  00:00:00     <br>centos-sclo-rh                                                                      | 3.0 kB  00:00:00     <br>epel                                                                                | 4.7 kB  00:00:00     <br>extras                                                                              | 2.9 kB  00:00:00     <br>remi-mirror                                                                         | 2.9 kB  00:00:00     <br>                                                                              | 2.9 kB  00:00:00     <br>update                                                                              | 2.9 kB  00:00:00     <br>(1/11): Percona/primary_db                                                          |  90 kB  00:00:00     <br>(2/11): base/7/x86_64/group_gz                                                      | 153 kB  00:00:00     <br>(3/11): epel/7/group_gz                                                             |  96 kB  00:00:00     <br>(4/11): extras/7/x86_64/primary_db                                                  | 246 kB  00:00:00     <br>(5/11): epel/7/updateinfo                                                           | 1.0 MB  00:00:01     <br>(6/11): remi-mirror/primary_db                                                      | 1.5 MB  00:00:00     <br>(7/11):  /7/primary_db                                                        | 1.5 MB  00:00:00     <br>(8/11): centos-sclo-rh/7/x86_64/primary_db                                          | 3.8 MB  00:00:06     <br>(9/11): base/7/x86_64/primary_db                                                    | 6.1 MB  00:00:08     <br>(10/11): epel/7/primary_db                                                          | 7.0 MB  00:00:07     <br>(11/11): update/7/x86_64/primary_db                                                 |  14 MB  00:00:07     <br>1007 packages excluded due to repository priority protections<br>Resolving Dependencies<br>--&gt; Running transaction check<br>---&gt; Package java<span class="hljs-string">-1</span>.8.0-openjdk-devel.x86_64 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 will be installed<br>--&gt; Processing Dependency: java<span class="hljs-string">-1</span>.8.0-openjdk(x86<span class="hljs-string">-64</span>) = 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-devel<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libjvm.so()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-devel<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libjava.so()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-devel<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libX11.so.6()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-devel<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Running transaction check<br>---&gt; Package java<span class="hljs-string">-1</span>.8.0-openjdk.x86_64 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 will be installed<br>--&gt; Processing Dependency: java<span class="hljs-string">-1</span>.8.0-openjdk-headless(x86<span class="hljs-string">-64</span>) = 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: xorg-x11-fonts-Type1 for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libpng15.so.15(PNG15_0)(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libjpeg.so.62(LIBJPEG_6.2)(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libasound.so.2(ALSA_0.9.0rc4)(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libasound.so.2(ALSA_0.9)(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libXcomposite(x86<span class="hljs-string">-64</span>) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: gtk2(x86<span class="hljs-string">-64</span>) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: fontconfig(x86<span class="hljs-string">-64</span>) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libpng15.so.15()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libjpeg.so.62()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libgif.so.4()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libasound.so.2()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libXtst.so.6()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libXrender.so.1()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libXi.so.6()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libXext.so.6()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>---&gt; Package java<span class="hljs-string">-1</span>.8.0-openjdk-headless.x86_64 1:1.8.0.322.b06<span class="hljs-string">-1</span>.el7_9 will be installed<br>--&gt; Processing Dependency: tzdata-java &gt;= 2021e for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: copy-jdk-configs &gt;= 3.3 for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: pcsc-lite-libs(x86<span class="hljs-string">-64</span>) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: lksctp-tools(x86<span class="hljs-string">-64</span>) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: jpackage-utils for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libfreetype.so.6()(64bit) for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.322.b06<span class="hljs-string">-1</span>.el7_9.x86_64<br>---&gt; Package libX11.x86_64 0:1.6.7<span class="hljs-string">-4</span>.el7_9 will be installed<br>--&gt; Processing Dependency: libX11-common &gt;= 1.6.7<span class="hljs-string">-4</span>.el7_9 for package: libX11<span class="hljs-string">-1</span>.6.7<span class="hljs-string">-4</span>.el7_9.x86_64<br>--&gt; Processing Dependency: libxcb.so.1()(64bit) for package: libX11<span class="hljs-string">-1</span>.6.7<span class="hljs-string">-4</span>.el7_9.x86_64<br>--&gt; Running transaction check<br>---&gt; Package alsa-lib.x86_64 0:1.1.8<span class="hljs-string">-1</span>.el7 will be installed<br>---&gt; Package copy-jdk-configs.noarch 0:3.3<span class="hljs-string">-10</span>.el7_5 will be installed<br>---&gt; Package fontconfig.x86_64 0:2.13.0<span class="hljs-string">-4</span>.3.el7 will be installed<br>--&gt; Processing Dependency: fontpackages-filesystem for package: fontconfig<span class="hljs-string">-2</span>.13.0<span class="hljs-string">-4</span>.3.el7.x86_64<br>--&gt; Processing Dependency: dejavu-sans-fonts for package: fontconfig<span class="hljs-string">-2</span>.13.0<span class="hljs-string">-4</span>.3.el7.x86_64<br>---&gt; Package freetype.x86_64 0:2.8<span class="hljs-string">-14</span>.el7_9.1 will be installed<br>---&gt; Package giflib.x86_64 0:4.1.6<span class="hljs-string">-9</span>.el7 will be installed<br>--&gt; Processing Dependency: libSM.so.6()(64bit) for package: giflib<span class="hljs-string">-4</span>.1.6<span class="hljs-string">-9</span>.el7.x86_64<br>--&gt; Processing Dependency: libICE.so.6()(64bit) for package: giflib<span class="hljs-string">-4</span>.1.6<span class="hljs-string">-9</span>.el7.x86_64<br>---&gt; Package gtk2.x86_64 0:2.24.31<span class="hljs-string">-1</span>.el7 will be installed<br>--&gt; Processing Dependency: pango &gt;= 1.20.0<span class="hljs-string">-1</span> for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libtiff &gt;= 3.6.1 for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXrandr &gt;= 1.2.99.4<span class="hljs-string">-2</span> for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: atk &gt;= 1.29.4<span class="hljs-string">-2</span> for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: hicolor-icon-theme for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: gtk-update-icon-cache for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libpangoft2<span class="hljs-string">-1</span>.0.so.0()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libpangocairo<span class="hljs-string">-1</span>.0.so.0()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libpango<span class="hljs-string">-1</span>.0.so.0()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libgdk_pixbuf<span class="hljs-string">-2</span>.0.so.0()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libcairo.so.2()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libatk<span class="hljs-string">-1</span>.0.so.0()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXrandr.so.2()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXinerama.so.1()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXfixes.so.3()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXdamage.so.1()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>--&gt; Processing Dependency: libXcursor.so.1()(64bit) for package: gtk2<span class="hljs-string">-2</span>.24.31<span class="hljs-string">-1</span>.el7.x86_64<br>---&gt; Package java<span class="hljs-string">-1</span>.8.0-openjdk.x86_64 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 will be installed<br>--&gt; Processing Dependency: java<span class="hljs-string">-1</span>.8.0-openjdk-headless(x86<span class="hljs-string">-64</span>) = 1:1.8.0.312.b07<span class="hljs-string">-1</span>.el7_9 for package: 1:java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.312.b07<span class="hljs-string">-1</span>.el7_9.x86_64<br>---&gt; Package javapackages-tools.noarch 0:3.4.1<span class="hljs-string">-11</span>.el7 will be installed<br>--&gt; Processing Dependency: python-javapackages = 3.4.1<span class="hljs-string">-11</span>.el7 for package: javapackages-tools<span class="hljs-string">-3</span>.4.1<span class="hljs-string">-11</span>.el7.noarch<br>--&gt; Processing Dependency: libxslt for package: javapackages-tools<span class="hljs-string">-3</span>.4.1<span class="hljs-string">-11</span>.el7.noarch<br>---&gt; Package libX11-common.noarch 0:1.6.7<span class="hljs-string">-4</span>.el7_9 will be installed<br>---&gt; Package libXcomposite.x86_64 0:0.4.4<span class="hljs-string">-4</span>.1.el7 will be installed<br>---&gt; Package libXext.x86_64 0:1.3.3<span class="hljs-string">-3</span>.el7 will be installed<br>---&gt; Package libXi.x86_64 0:1.7.9<span class="hljs-string">-1</span>.el7 will be installed<br>---&gt; Package libXrender.x86_64 0:0.9.10<span class="hljs-string">-1</span>.el7 will be installed<br>---&gt; Package libXtst.x86_64 0:1.2.3<span class="hljs-string">-1</span>.el7 will be installed<br>---&gt; Package libjpeg-turbo.x86_64 0:2.0.2<span class="hljs-string">-1</span> will be installed<br>---&gt; Package libpng.x86_64 2:1.5.13<span class="hljs-string">-8</span>.el7 will be installed<br>---&gt; Package libxcb.x86_64 0:1.13<span class="hljs-string">-1</span>.el7 will be installed<br>--&gt; Processing Dependency: libXau.so.6()(64bit) for package: libxcb<span class="hljs-string">-1</span>.13<span class="hljs-string">-1</span>.el7.x86_64<br>---&gt; Package lksctp-tools.x86_64 0:1.0.17<span class="hljs-string">-2</span>.el7 will be installed<br>---&gt; Package pcsc-lite-libs.x86_64 0:1.8.8<span class="hljs-string">-8</span>.el7 will be installed<br>---&gt; Package tzdata-java.noarch 0:2021e<span class="hljs-string">-1</span>.el7 will be installed<br>---&gt; Package xorg-x11-fonts-Type1.noarch 0:7.5<span class="hljs-string">-9</span>.el7 will be installed<br>--&gt; Processing Dependency: ttmkfdir for package: xorg-x11-fonts-Type1<span class="hljs-string">-7</span>.5<span class="hljs-string">-9</span>.el7.noarch<br>--&gt; Processing Dependency: ttmkfdir for package: xorg-x11-fonts-Type1<span class="hljs-string">-7</span>.5<span class="hljs-string">-9</span>.el7.noarch<br>--&gt; Processing Dependency: mkfontdir for package: xorg-x11-fonts-Type1<span class="hljs-string">-7</span>.5<span class="hljs-string">-9</span>.el7.noarch<br>--&gt; Processing Dependency: mkfontdir for package: xorg-x11-fonts-Type1<span class="hljs-string">-7</span>.5<span class="hljs-string">-9</span>.el7.noarch<br>--&gt; Running transaction check<br>---&gt; Package atk.x86_64 0:2.28.1<span class="hljs-string">-2</span>.el7 will be installed<br>---&gt; Package cairo.x86_64 0:1.15.12<span class="hljs-string">-4</span>.el7 will be installed<br>--&gt; Processing Dependency: libpixman<span class="hljs-string">-1</span>.so.<br></code></pre></td></tr></table></figure>

<p>这时候发现了安装java-1.8.0-openjdk的指定版本不会报错</p>
<blockquote>
<p> yum install java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9</p>
</blockquote>
<p>接着执行就能正常安装了…</p>
<blockquote>
<p>yum install java-1.8.0-openjdk-devel-1.8.0.312.b07-1.el7_9</p>
</blockquote>
<h2 id="还没有解决的问题"><a href="#还没有解决的问题" class="headerlink" title="还没有解决的问题"></a>还没有解决的问题</h2><ul>
<li>为什么直接安装会报错呢？</li>
<li>为什么先安装不带devel再安装devel的就能够安装成功呢？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Vilden</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vildenhh@gmail.com</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
